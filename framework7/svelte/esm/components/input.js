/* input.svelte generated by Svelte v3.38.2 */
import {
	SvelteComponent,
	append,
	assign,
	attr,
	binding_callbacks,
	check_outros,
	compute_rest_props,
	compute_slots,
	create_component,
	create_slot,
	destroy_component,
	detach,
	element,
	empty,
	exclude_internal_props,
	get_spread_object,
	get_spread_update,
	group_outros,
	init,
	insert,
	listen,
	mount_component,
	noop,
	run_all,
	safe_not_equal,
	select_option,
	select_options,
	set_attributes,
	set_data,
	space,
	text,
	transition_in,
	transition_out,
	update_slot
} from "svelte/internal";

import { createEventDispatcher, onMount, afterUpdate, onDestroy } from "svelte";
import { colorClasses } from "../shared/mixins";
import { classNames, createEmitter } from "../shared/utils";
import { restProps } from "../shared/rest-props";
import { app, f7ready } from "../shared/f7";
import Toggle from "./toggle";
import Range from "./range";
import TextEditor from "./text-editor";
const get_info_slot_changes = dirty => ({});
const get_info_slot_context = ctx => ({});
const get_error_message_slot_changes = dirty => ({});
const get_error_message_slot_context = ctx => ({});

// (626:0) {:else}
function create_else_block_1(ctx) {
	let input;
	let input_validate_value;
	let input_data_validate_value;
	let input_data_validate_on_blur_value;
	let input_data_error_message_value;
	let input_value_value;
	let mounted;
	let dispose;

	let input_levels = [
		{ style: /*inputStyle*/ ctx[23] },
		{ name: /*name*/ ctx[2] },
		{ type: /*inputType*/ ctx[35] },
		{ placeholder: /*placeholder*/ ctx[3] },
		{ id: /*inputId*/ ctx[4] },
		{ size: /*size*/ ctx[5] },
		{ accept: /*accept*/ ctx[6] },
		{ autocomplete: /*autocomplete*/ ctx[7] },
		{ autocorrect: /*autocorrect*/ ctx[8] },
		{
			autocapitalize: /*autocapitalize*/ ctx[9]
		},
		{ spellcheck: /*spellcheck*/ ctx[10] },
		{ autofocus: /*autofocus*/ ctx[11] },
		{ autosave: /*autosave*/ ctx[12] },
		{ checked: /*checked*/ ctx[13] },
		{ disabled: /*disabled*/ ctx[14] },
		{ max: /*max*/ ctx[15] },
		{ maxlength: /*maxlength*/ ctx[18] },
		{ min: /*min*/ ctx[16] },
		{ minlength: /*minlength*/ ctx[19] },
		{ step: /*step*/ ctx[17] },
		{ multiple: /*multiple*/ ctx[20] },
		{ readOnly: /*readonly*/ ctx[21] },
		{ required: /*required*/ ctx[22] },
		{ pattern: /*pattern*/ ctx[24] },
		{
			validate: input_validate_value = typeof /*validate*/ ctx[25] === "string" && /*validate*/ ctx[25].length
			? /*validate*/ ctx[25]
			: undefined
		},
		{
			"data-validate": input_data_validate_value = /*validate*/ ctx[25] === true || /*validate*/ ctx[25] === "" || /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
			? true
			: undefined
		},
		{
			"data-validate-on-blur": input_data_validate_on_blur_value = /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
			? true
			: undefined
		},
		{ tabindex: /*tabindex*/ ctx[27] },
		{
			"data-error-message": input_data_error_message_value = /*errorMessageForce*/ ctx[31]
			? undefined
			: /*errorMessage*/ ctx[30]
		},
		{ class: /*inputClassName*/ ctx[39] },
		{
			value: input_value_value = /*type*/ ctx[1] === "datepicker" || /*type*/ ctx[1] === "colorpicker" || /*type*/ ctx[1] === "file"
			? ""
			: /*inputValue*/ ctx[37]
		},
		restProps(/*$$restProps*/ ctx[46])
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = assign(input_data, input_levels[i]);
	}

	return {
		c() {
			input = element("input");
			set_attributes(input, input_data);
		},
		m(target, anchor) {
			insert(target, input, anchor);
			input.value = input_data.value;
			/*input_binding_1*/ ctx[65](input);

			if (!mounted) {
				dispose = [
					listen(input, "focus", /*onFocus*/ ctx[43]),
					listen(input, "blur", /*onBlur*/ ctx[44]),
					listen(input, "input", /*onInput*/ ctx[42]),
					listen(input, "change", /*onChange*/ ctx[45])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			set_attributes(input, input_data = get_spread_update(input_levels, [
				dirty[0] & /*inputStyle*/ 8388608 && { style: /*inputStyle*/ ctx[23] },
				dirty[0] & /*name*/ 4 && { name: /*name*/ ctx[2] },
				dirty[1] & /*inputType*/ 16 && { type: /*inputType*/ ctx[35] },
				dirty[0] & /*placeholder*/ 8 && { placeholder: /*placeholder*/ ctx[3] },
				dirty[0] & /*inputId*/ 16 && { id: /*inputId*/ ctx[4] },
				dirty[0] & /*size*/ 32 && { size: /*size*/ ctx[5] },
				dirty[0] & /*accept*/ 64 && { accept: /*accept*/ ctx[6] },
				dirty[0] & /*autocomplete*/ 128 && { autocomplete: /*autocomplete*/ ctx[7] },
				dirty[0] & /*autocorrect*/ 256 && { autocorrect: /*autocorrect*/ ctx[8] },
				dirty[0] & /*autocapitalize*/ 512 && {
					autocapitalize: /*autocapitalize*/ ctx[9]
				},
				dirty[0] & /*spellcheck*/ 1024 && { spellcheck: /*spellcheck*/ ctx[10] },
				dirty[0] & /*autofocus*/ 2048 && { autofocus: /*autofocus*/ ctx[11] },
				dirty[0] & /*autosave*/ 4096 && { autosave: /*autosave*/ ctx[12] },
				dirty[0] & /*checked*/ 8192 && { checked: /*checked*/ ctx[13] },
				dirty[0] & /*disabled*/ 16384 && { disabled: /*disabled*/ ctx[14] },
				dirty[0] & /*max*/ 32768 && { max: /*max*/ ctx[15] },
				dirty[0] & /*maxlength*/ 262144 && { maxlength: /*maxlength*/ ctx[18] },
				dirty[0] & /*min*/ 65536 && { min: /*min*/ ctx[16] },
				dirty[0] & /*minlength*/ 524288 && { minlength: /*minlength*/ ctx[19] },
				dirty[0] & /*step*/ 131072 && { step: /*step*/ ctx[17] },
				dirty[0] & /*multiple*/ 1048576 && { multiple: /*multiple*/ ctx[20] },
				dirty[0] & /*readonly*/ 2097152 && { readOnly: /*readonly*/ ctx[21] },
				dirty[0] & /*required*/ 4194304 && { required: /*required*/ ctx[22] },
				dirty[0] & /*pattern*/ 16777216 && { pattern: /*pattern*/ ctx[24] },
				dirty[0] & /*validate*/ 33554432 && input_validate_value !== (input_validate_value = typeof /*validate*/ ctx[25] === "string" && /*validate*/ ctx[25].length
				? /*validate*/ ctx[25]
				: undefined) && { validate: input_validate_value },
				dirty[0] & /*validate, validateOnBlur*/ 100663296 && input_data_validate_value !== (input_data_validate_value = /*validate*/ ctx[25] === true || /*validate*/ ctx[25] === "" || /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
				? true
				: undefined) && {
					"data-validate": input_data_validate_value
				},
				dirty[0] & /*validateOnBlur*/ 67108864 && input_data_validate_on_blur_value !== (input_data_validate_on_blur_value = /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
				? true
				: undefined) && {
					"data-validate-on-blur": input_data_validate_on_blur_value
				},
				dirty[0] & /*tabindex*/ 134217728 && { tabindex: /*tabindex*/ ctx[27] },
				dirty[0] & /*errorMessage*/ 1073741824 | dirty[1] & /*errorMessageForce*/ 1 && input_data_error_message_value !== (input_data_error_message_value = /*errorMessageForce*/ ctx[31]
				? undefined
				: /*errorMessage*/ ctx[30]) && {
					"data-error-message": input_data_error_message_value
				},
				dirty[1] & /*inputClassName*/ 256 && { class: /*inputClassName*/ ctx[39] },
				dirty[0] & /*type*/ 2 | dirty[1] & /*inputValue*/ 64 && input_value_value !== (input_value_value = /*type*/ ctx[1] === "datepicker" || /*type*/ ctx[1] === "colorpicker" || /*type*/ ctx[1] === "file"
				? ""
				: /*inputValue*/ ctx[37]) && input.value !== input_value_value && { value: input_value_value },
				dirty[1] & /*$$restProps*/ 32768 && restProps(/*$$restProps*/ ctx[46])
			]));

			if ("value" in input_data) {
				input.value = input_data.value;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(input);
			/*input_binding_1*/ ctx[65](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (614:32) 
function create_if_block_13(ctx) {
	let texteditor;
	let current;

	const texteditor_spread_levels = [
		{
			value: typeof /*value*/ ctx[0] === "undefined"
			? ""
			: /*value*/ ctx[0]
		},
		{ resizable: /*resizable*/ ctx[28] },
		{ placeholder: /*placeholder*/ ctx[3] },
		{ onTextEditorFocus: /*onFocus*/ ctx[43] },
		{ onTextEditorBlur: /*onBlur*/ ctx[44] },
		{ onTextEditorInput: /*onInput*/ ctx[42] },
		{ onTextEditorChange: /*onChange*/ ctx[45] },
		/*textEditorParams*/ ctx[34],
		restProps(/*$$restProps*/ ctx[46])
	];

	let texteditor_props = {};

	for (let i = 0; i < texteditor_spread_levels.length; i += 1) {
		texteditor_props = assign(texteditor_props, texteditor_spread_levels[i]);
	}

	texteditor = new TextEditor({ props: texteditor_props });

	return {
		c() {
			create_component(texteditor.$$.fragment);
		},
		m(target, anchor) {
			mount_component(texteditor, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const texteditor_changes = (dirty[0] & /*value, resizable, placeholder*/ 268435465 | dirty[1] & /*onFocus, onBlur, onInput, onChange, textEditorParams, $$restProps*/ 63496)
			? get_spread_update(texteditor_spread_levels, [
					dirty[0] & /*value*/ 1 && {
						value: typeof /*value*/ ctx[0] === "undefined"
						? ""
						: /*value*/ ctx[0]
					},
					dirty[0] & /*resizable*/ 268435456 && { resizable: /*resizable*/ ctx[28] },
					dirty[0] & /*placeholder*/ 8 && { placeholder: /*placeholder*/ ctx[3] },
					dirty[1] & /*onFocus*/ 4096 && { onTextEditorFocus: /*onFocus*/ ctx[43] },
					dirty[1] & /*onBlur*/ 8192 && { onTextEditorBlur: /*onBlur*/ ctx[44] },
					dirty[1] & /*onInput*/ 2048 && { onTextEditorInput: /*onInput*/ ctx[42] },
					dirty[1] & /*onChange*/ 16384 && { onTextEditorChange: /*onChange*/ ctx[45] },
					dirty[1] & /*textEditorParams*/ 8 && get_spread_object(/*textEditorParams*/ ctx[34]),
					dirty[1] & /*$$restProps*/ 32768 && get_spread_object(restProps(/*$$restProps*/ ctx[46]))
				])
			: {};

			texteditor.$set(texteditor_changes);
		},
		i(local) {
			if (current) return;
			transition_in(texteditor.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(texteditor.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(texteditor, detaching);
		}
	};
}

// (601:27) 
function create_if_block_12(ctx) {
	let range;
	let current;

	const range_spread_levels = [
		{ value: /*value*/ ctx[0] },
		{ disabled: /*disabled*/ ctx[14] },
		{ min: /*min*/ ctx[16] },
		{ max: /*max*/ ctx[15] },
		{ step: /*step*/ ctx[17] },
		{ name: /*name*/ ctx[2] },
		{ id: /*inputId*/ ctx[4] },
		{ input: true },
		restProps(/*$$restProps*/ ctx[46])
	];

	let range_props = {};

	for (let i = 0; i < range_spread_levels.length; i += 1) {
		range_props = assign(range_props, range_spread_levels[i]);
	}

	range = new Range({ props: range_props });
	range.$on("rangeChange", /*onChange*/ ctx[45]);

	return {
		c() {
			create_component(range.$$.fragment);
		},
		m(target, anchor) {
			mount_component(range, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const range_changes = (dirty[0] & /*value, disabled, min, max, step, name, inputId*/ 245781 | dirty[1] & /*$$restProps*/ 32768)
			? get_spread_update(range_spread_levels, [
					dirty[0] & /*value*/ 1 && { value: /*value*/ ctx[0] },
					dirty[0] & /*disabled*/ 16384 && { disabled: /*disabled*/ ctx[14] },
					dirty[0] & /*min*/ 65536 && { min: /*min*/ ctx[16] },
					dirty[0] & /*max*/ 32768 && { max: /*max*/ ctx[15] },
					dirty[0] & /*step*/ 131072 && { step: /*step*/ ctx[17] },
					dirty[0] & /*name*/ 4 && { name: /*name*/ ctx[2] },
					dirty[0] & /*inputId*/ 16 && { id: /*inputId*/ ctx[4] },
					range_spread_levels[7],
					dirty[1] & /*$$restProps*/ 32768 && get_spread_object(restProps(/*$$restProps*/ ctx[46]))
				])
			: {};

			range.$set(range_changes);
		},
		i(local) {
			if (current) return;
			transition_in(range.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(range.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(range, detaching);
		}
	};
}

// (590:28) 
function create_if_block_11(ctx) {
	let toggle;
	let current;

	const toggle_spread_levels = [
		{ checked: /*checked*/ ctx[13] },
		{ readonly: /*readonly*/ ctx[21] },
		{ name: /*name*/ ctx[2] },
		{ value: /*value*/ ctx[0] },
		{ disabled: /*disabled*/ ctx[14] },
		{ id: /*inputId*/ ctx[4] },
		restProps(/*$$restProps*/ ctx[46])
	];

	let toggle_props = {};

	for (let i = 0; i < toggle_spread_levels.length; i += 1) {
		toggle_props = assign(toggle_props, toggle_spread_levels[i]);
	}

	toggle = new Toggle({ props: toggle_props });
	toggle.$on("change", /*onChange*/ ctx[45]);

	return {
		c() {
			create_component(toggle.$$.fragment);
		},
		m(target, anchor) {
			mount_component(toggle, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const toggle_changes = (dirty[0] & /*checked, readonly, name, value, disabled, inputId*/ 2121749 | dirty[1] & /*$$restProps*/ 32768)
			? get_spread_update(toggle_spread_levels, [
					dirty[0] & /*checked*/ 8192 && { checked: /*checked*/ ctx[13] },
					dirty[0] & /*readonly*/ 2097152 && { readonly: /*readonly*/ ctx[21] },
					dirty[0] & /*name*/ 4 && { name: /*name*/ ctx[2] },
					dirty[0] & /*value*/ 1 && { value: /*value*/ ctx[0] },
					dirty[0] & /*disabled*/ 16384 && { disabled: /*disabled*/ ctx[14] },
					dirty[0] & /*inputId*/ 16 && { id: /*inputId*/ ctx[4] },
					dirty[1] & /*$$restProps*/ 32768 && get_spread_object(restProps(/*$$restProps*/ ctx[46]))
				])
			: {};

			toggle.$set(toggle_changes);
		},
		i(local) {
			if (current) return;
			transition_in(toggle.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(toggle.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(toggle, detaching);
		}
	};
}

// (546:30) 
function create_if_block_10(ctx) {
	let textarea;
	let textarea_validate_value;
	let textarea_data_validate_value;
	let textarea_data_validate_on_blur_value;
	let textarea_data_error_message_value;
	let mounted;
	let dispose;

	let textarea_levels = [
		{ style: /*inputStyle*/ ctx[23] },
		{ name: /*name*/ ctx[2] },
		{ placeholder: /*placeholder*/ ctx[3] },
		{ id: /*inputId*/ ctx[4] },
		{ size: /*size*/ ctx[5] },
		{ accept: /*accept*/ ctx[6] },
		{ autocomplete: /*autocomplete*/ ctx[7] },
		{ autocorrect: /*autocorrect*/ ctx[8] },
		{
			autocapitalize: /*autocapitalize*/ ctx[9]
		},
		{ spellcheck: /*spellcheck*/ ctx[10] },
		{ autofocus: /*autofocus*/ ctx[11] },
		{ autosave: /*autosave*/ ctx[12] },
		{ checked: /*checked*/ ctx[13] },
		{ disabled: /*disabled*/ ctx[14] },
		{ max: /*max*/ ctx[15] },
		{ maxlength: /*maxlength*/ ctx[18] },
		{ min: /*min*/ ctx[16] },
		{ minlength: /*minlength*/ ctx[19] },
		{ step: /*step*/ ctx[17] },
		{ multiple: /*multiple*/ ctx[20] },
		{ readOnly: /*readonly*/ ctx[21] },
		{ required: /*required*/ ctx[22] },
		{ pattern: /*pattern*/ ctx[24] },
		{
			validate: textarea_validate_value = typeof /*validate*/ ctx[25] === "string" && /*validate*/ ctx[25].length
			? /*validate*/ ctx[25]
			: undefined
		},
		{
			"data-validate": textarea_data_validate_value = /*validate*/ ctx[25] === true || /*validate*/ ctx[25] === "" || /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
			? true
			: undefined
		},
		{
			"data-validate-on-blur": textarea_data_validate_on_blur_value = /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
			? true
			: undefined
		},
		{ tabindex: /*tabindex*/ ctx[27] },
		{
			"data-error-message": textarea_data_error_message_value = /*errorMessageForce*/ ctx[31]
			? undefined
			: /*errorMessage*/ ctx[30]
		},
		{ class: /*inputClassName*/ ctx[39] },
		{ value: /*inputValue*/ ctx[37] },
		restProps(/*$$restProps*/ ctx[46])
	];

	let textarea_data = {};

	for (let i = 0; i < textarea_levels.length; i += 1) {
		textarea_data = assign(textarea_data, textarea_levels[i]);
	}

	return {
		c() {
			textarea = element("textarea");
			set_attributes(textarea, textarea_data);
		},
		m(target, anchor) {
			insert(target, textarea, anchor);
			/*textarea_binding_1*/ ctx[64](textarea);

			if (!mounted) {
				dispose = [
					listen(textarea, "focus", /*onFocus*/ ctx[43]),
					listen(textarea, "blur", /*onBlur*/ ctx[44]),
					listen(textarea, "input", /*onInput*/ ctx[42]),
					listen(textarea, "change", /*onChange*/ ctx[45])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			set_attributes(textarea, textarea_data = get_spread_update(textarea_levels, [
				dirty[0] & /*inputStyle*/ 8388608 && { style: /*inputStyle*/ ctx[23] },
				dirty[0] & /*name*/ 4 && { name: /*name*/ ctx[2] },
				dirty[0] & /*placeholder*/ 8 && { placeholder: /*placeholder*/ ctx[3] },
				dirty[0] & /*inputId*/ 16 && { id: /*inputId*/ ctx[4] },
				dirty[0] & /*size*/ 32 && { size: /*size*/ ctx[5] },
				dirty[0] & /*accept*/ 64 && { accept: /*accept*/ ctx[6] },
				dirty[0] & /*autocomplete*/ 128 && { autocomplete: /*autocomplete*/ ctx[7] },
				dirty[0] & /*autocorrect*/ 256 && { autocorrect: /*autocorrect*/ ctx[8] },
				dirty[0] & /*autocapitalize*/ 512 && {
					autocapitalize: /*autocapitalize*/ ctx[9]
				},
				dirty[0] & /*spellcheck*/ 1024 && { spellcheck: /*spellcheck*/ ctx[10] },
				dirty[0] & /*autofocus*/ 2048 && { autofocus: /*autofocus*/ ctx[11] },
				dirty[0] & /*autosave*/ 4096 && { autosave: /*autosave*/ ctx[12] },
				dirty[0] & /*checked*/ 8192 && { checked: /*checked*/ ctx[13] },
				dirty[0] & /*disabled*/ 16384 && { disabled: /*disabled*/ ctx[14] },
				dirty[0] & /*max*/ 32768 && { max: /*max*/ ctx[15] },
				dirty[0] & /*maxlength*/ 262144 && { maxlength: /*maxlength*/ ctx[18] },
				dirty[0] & /*min*/ 65536 && { min: /*min*/ ctx[16] },
				dirty[0] & /*minlength*/ 524288 && { minlength: /*minlength*/ ctx[19] },
				dirty[0] & /*step*/ 131072 && { step: /*step*/ ctx[17] },
				dirty[0] & /*multiple*/ 1048576 && { multiple: /*multiple*/ ctx[20] },
				dirty[0] & /*readonly*/ 2097152 && { readOnly: /*readonly*/ ctx[21] },
				dirty[0] & /*required*/ 4194304 && { required: /*required*/ ctx[22] },
				dirty[0] & /*pattern*/ 16777216 && { pattern: /*pattern*/ ctx[24] },
				dirty[0] & /*validate*/ 33554432 && textarea_validate_value !== (textarea_validate_value = typeof /*validate*/ ctx[25] === "string" && /*validate*/ ctx[25].length
				? /*validate*/ ctx[25]
				: undefined) && { validate: textarea_validate_value },
				dirty[0] & /*validate, validateOnBlur*/ 100663296 && textarea_data_validate_value !== (textarea_data_validate_value = /*validate*/ ctx[25] === true || /*validate*/ ctx[25] === "" || /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
				? true
				: undefined) && {
					"data-validate": textarea_data_validate_value
				},
				dirty[0] & /*validateOnBlur*/ 67108864 && textarea_data_validate_on_blur_value !== (textarea_data_validate_on_blur_value = /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
				? true
				: undefined) && {
					"data-validate-on-blur": textarea_data_validate_on_blur_value
				},
				dirty[0] & /*tabindex*/ 134217728 && { tabindex: /*tabindex*/ ctx[27] },
				dirty[0] & /*errorMessage*/ 1073741824 | dirty[1] & /*errorMessageForce*/ 1 && textarea_data_error_message_value !== (textarea_data_error_message_value = /*errorMessageForce*/ ctx[31]
				? undefined
				: /*errorMessage*/ ctx[30]) && {
					"data-error-message": textarea_data_error_message_value
				},
				dirty[1] & /*inputClassName*/ 256 && { class: /*inputClassName*/ ctx[39] },
				dirty[1] & /*inputValue*/ 64 && { value: /*inputValue*/ ctx[37] },
				dirty[1] & /*$$restProps*/ 32768 && restProps(/*$$restProps*/ ctx[46])
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(textarea);
			/*textarea_binding_1*/ ctx[64](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (500:28) 
function create_if_block_9(ctx) {
	let select;
	let select_validate_value;
	let select_data_validate_value;
	let select_data_validate_on_blur_value;
	let select_data_error_message_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[59].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[58], null);

	let select_levels = [
		{ style: /*inputStyle*/ ctx[23] },
		{ name: /*name*/ ctx[2] },
		{ placeholder: /*placeholder*/ ctx[3] },
		{ id: /*inputId*/ ctx[4] },
		{ size: /*size*/ ctx[5] },
		{ accept: /*accept*/ ctx[6] },
		{ autocomplete: /*autocomplete*/ ctx[7] },
		{ autocorrect: /*autocorrect*/ ctx[8] },
		{
			autocapitalize: /*autocapitalize*/ ctx[9]
		},
		{ spellcheck: /*spellcheck*/ ctx[10] },
		{ autofocus: /*autofocus*/ ctx[11] },
		{ autosave: /*autosave*/ ctx[12] },
		{ checked: /*checked*/ ctx[13] },
		{ disabled: /*disabled*/ ctx[14] },
		{ max: /*max*/ ctx[15] },
		{ maxlength: /*maxlength*/ ctx[18] },
		{ min: /*min*/ ctx[16] },
		{ minlength: /*minlength*/ ctx[19] },
		{ step: /*step*/ ctx[17] },
		{ multiple: /*multiple*/ ctx[20] },
		{ readonly: /*readonly*/ ctx[21] },
		{ required: /*required*/ ctx[22] },
		{ pattern: /*pattern*/ ctx[24] },
		{
			validate: select_validate_value = typeof /*validate*/ ctx[25] === "string" && /*validate*/ ctx[25].length
			? /*validate*/ ctx[25]
			: undefined
		},
		{
			"data-validate": select_data_validate_value = /*validate*/ ctx[25] === true || /*validate*/ ctx[25] === "" || /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
			? true
			: undefined
		},
		{
			"data-validate-on-blur": select_data_validate_on_blur_value = /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
			? true
			: undefined
		},
		{ tabindex: /*tabindex*/ ctx[27] },
		{
			"data-error-message": select_data_error_message_value = /*errorMessageForce*/ ctx[31]
			? undefined
			: /*errorMessage*/ ctx[30]
		},
		{ class: /*inputClassName*/ ctx[39] },
		{ value: /*inputValue*/ ctx[37] },
		restProps(/*$$restProps*/ ctx[46])
	];

	let select_data = {};

	for (let i = 0; i < select_levels.length; i += 1) {
		select_data = assign(select_data, select_levels[i]);
	}

	return {
		c() {
			select = element("select");
			if (default_slot) default_slot.c();
			set_attributes(select, select_data);
		},
		m(target, anchor) {
			insert(target, select, anchor);

			if (default_slot) {
				default_slot.m(select, null);
			}

			if (select_data.multiple) select_options(select, select_data.value);
			/*select_binding_1*/ ctx[63](select);
			current = true;

			if (!mounted) {
				dispose = [
					listen(select, "focus", /*onFocus*/ ctx[43]),
					listen(select, "blur", /*onBlur*/ ctx[44]),
					listen(select, "input", /*onInput*/ ctx[42]),
					listen(select, "change", /*onChange*/ ctx[45])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 134217728)) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[58], dirty, null, null);
				}
			}

			set_attributes(select, select_data = get_spread_update(select_levels, [
				(!current || dirty[0] & /*inputStyle*/ 8388608) && { style: /*inputStyle*/ ctx[23] },
				(!current || dirty[0] & /*name*/ 4) && { name: /*name*/ ctx[2] },
				(!current || dirty[0] & /*placeholder*/ 8) && { placeholder: /*placeholder*/ ctx[3] },
				(!current || dirty[0] & /*inputId*/ 16) && { id: /*inputId*/ ctx[4] },
				(!current || dirty[0] & /*size*/ 32) && { size: /*size*/ ctx[5] },
				(!current || dirty[0] & /*accept*/ 64) && { accept: /*accept*/ ctx[6] },
				(!current || dirty[0] & /*autocomplete*/ 128) && { autocomplete: /*autocomplete*/ ctx[7] },
				(!current || dirty[0] & /*autocorrect*/ 256) && { autocorrect: /*autocorrect*/ ctx[8] },
				(!current || dirty[0] & /*autocapitalize*/ 512) && {
					autocapitalize: /*autocapitalize*/ ctx[9]
				},
				(!current || dirty[0] & /*spellcheck*/ 1024) && { spellcheck: /*spellcheck*/ ctx[10] },
				(!current || dirty[0] & /*autofocus*/ 2048) && { autofocus: /*autofocus*/ ctx[11] },
				(!current || dirty[0] & /*autosave*/ 4096) && { autosave: /*autosave*/ ctx[12] },
				(!current || dirty[0] & /*checked*/ 8192) && { checked: /*checked*/ ctx[13] },
				(!current || dirty[0] & /*disabled*/ 16384) && { disabled: /*disabled*/ ctx[14] },
				(!current || dirty[0] & /*max*/ 32768) && { max: /*max*/ ctx[15] },
				(!current || dirty[0] & /*maxlength*/ 262144) && { maxlength: /*maxlength*/ ctx[18] },
				(!current || dirty[0] & /*min*/ 65536) && { min: /*min*/ ctx[16] },
				(!current || dirty[0] & /*minlength*/ 524288) && { minlength: /*minlength*/ ctx[19] },
				(!current || dirty[0] & /*step*/ 131072) && { step: /*step*/ ctx[17] },
				(!current || dirty[0] & /*multiple*/ 1048576) && { multiple: /*multiple*/ ctx[20] },
				(!current || dirty[0] & /*readonly*/ 2097152) && { readonly: /*readonly*/ ctx[21] },
				(!current || dirty[0] & /*required*/ 4194304) && { required: /*required*/ ctx[22] },
				(!current || dirty[0] & /*pattern*/ 16777216) && { pattern: /*pattern*/ ctx[24] },
				(!current || dirty[0] & /*validate*/ 33554432 && select_validate_value !== (select_validate_value = typeof /*validate*/ ctx[25] === "string" && /*validate*/ ctx[25].length
				? /*validate*/ ctx[25]
				: undefined)) && { validate: select_validate_value },
				(!current || dirty[0] & /*validate, validateOnBlur*/ 100663296 && select_data_validate_value !== (select_data_validate_value = /*validate*/ ctx[25] === true || /*validate*/ ctx[25] === "" || /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
				? true
				: undefined)) && {
					"data-validate": select_data_validate_value
				},
				(!current || dirty[0] & /*validateOnBlur*/ 67108864 && select_data_validate_on_blur_value !== (select_data_validate_on_blur_value = /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
				? true
				: undefined)) && {
					"data-validate-on-blur": select_data_validate_on_blur_value
				},
				(!current || dirty[0] & /*tabindex*/ 134217728) && { tabindex: /*tabindex*/ ctx[27] },
				(!current || dirty[0] & /*errorMessage*/ 1073741824 | dirty[1] & /*errorMessageForce*/ 1 && select_data_error_message_value !== (select_data_error_message_value = /*errorMessageForce*/ ctx[31]
				? undefined
				: /*errorMessage*/ ctx[30])) && {
					"data-error-message": select_data_error_message_value
				},
				(!current || dirty[1] & /*inputClassName*/ 256) && { class: /*inputClassName*/ ctx[39] },
				(!current || dirty[1] & /*inputValue*/ 64) && { value: /*inputValue*/ ctx[37] },
				dirty[1] & /*$$restProps*/ 32768 && restProps(/*$$restProps*/ ctx[46])
			]));

			if (dirty[0] & /*inputStyle, name, placeholder, inputId, size, accept, autocomplete, autocorrect, autocapitalize, spellcheck, autofocus, autosave, checked, disabled, max, maxlength, min, minlength, step, multiple, readonly, required, pattern, validate, validateOnBlur, tabindex, errorMessage*/ 1342177276 | dirty[1] & /*errorMessageForce, inputClassName, inputValue, $$restProps*/ 33089 && select_data.multiple) select_options(select, select_data.value);
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(select);
			if (default_slot) default_slot.d(detaching);
			/*select_binding_1*/ ctx[63](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (326:0) {#if wrap}
function create_if_block(ctx) {
	let div;
	let current_block_type_index;
	let if_block0;
	let t0;
	let t1;
	let t2;
	let current;

	const if_block_creators = [
		create_if_block_4,
		create_if_block_5,
		create_if_block_6,
		create_if_block_7,
		create_if_block_8,
		create_else_block
	];

	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*type*/ ctx[1] === "select") return 0;
		if (/*type*/ ctx[1] === "textarea") return 1;
		if (/*type*/ ctx[1] === "toggle") return 2;
		if (/*type*/ ctx[1] === "range") return 3;
		if (/*type*/ ctx[1] === "texteditor") return 4;
		return 5;
	}

	current_block_type_index = select_block_type_1(ctx, [-1]);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let if_block1 = (/*errorMessage*/ ctx[30] || /*hasErrorSlots*/ ctx[41]) && /*errorMessageForce*/ ctx[31] && create_if_block_3(ctx);
	let if_block2 = /*clearButton*/ ctx[29] && create_if_block_2(ctx);
	let if_block3 = (/*info*/ ctx[32] || /*hasInfoSlots*/ ctx[40]) && create_if_block_1(ctx);
	let div_levels = [{ class: /*wrapClasses*/ ctx[38] }, restProps(/*$$restProps*/ ctx[46])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			t2 = space();
			if (if_block3) if_block3.c();
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			append(div, t0);
			if (if_block1) if_block1.m(div, null);
			append(div, t1);
			if (if_block2) if_block2.m(div, null);
			append(div, t2);
			if (if_block3) if_block3.m(div, null);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				} else {
					if_block0.p(ctx, dirty);
				}

				transition_in(if_block0, 1);
				if_block0.m(div, t0);
			}

			if ((/*errorMessage*/ ctx[30] || /*hasErrorSlots*/ ctx[41]) && /*errorMessageForce*/ ctx[31]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*errorMessage*/ 1073741824 | dirty[1] & /*hasErrorSlots, errorMessageForce*/ 1025) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_3(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (/*clearButton*/ ctx[29]) {
				if (if_block2) {
					
				} else {
					if_block2 = create_if_block_2(ctx);
					if_block2.c();
					if_block2.m(div, t2);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (/*info*/ ctx[32] || /*hasInfoSlots*/ ctx[40]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[1] & /*info, hasInfoSlots*/ 514) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_1(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(div, null);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty[1] & /*wrapClasses*/ 128) && { class: /*wrapClasses*/ ctx[38] },
				dirty[1] & /*$$restProps*/ 32768 && restProps(/*$$restProps*/ ctx[46])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block3);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block3);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if_blocks[current_block_type_index].d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
		}
	};
}

// (441:4) {:else}
function create_else_block(ctx) {
	let input;
	let input_validate_value;
	let input_data_validate_value;
	let input_data_validate_on_blur_value;
	let input_data_error_message_value;
	let input_value_value;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "style", /*inputStyle*/ ctx[23]);
			attr(input, "name", /*name*/ ctx[2]);
			attr(input, "type", /*inputType*/ ctx[35]);
			attr(input, "placeholder", /*placeholder*/ ctx[3]);
			attr(input, "id", /*inputId*/ ctx[4]);
			attr(input, "size", /*size*/ ctx[5]);
			attr(input, "accept", /*accept*/ ctx[6]);
			attr(input, "autocomplete", /*autocomplete*/ ctx[7]);
			attr(input, "autocorrect", /*autocorrect*/ ctx[8]);
			attr(input, "autocapitalize", /*autocapitalize*/ ctx[9]);
			attr(input, "spellcheck", /*spellcheck*/ ctx[10]);
			input.autofocus = /*autofocus*/ ctx[11];
			attr(input, "autosave", /*autosave*/ ctx[12]);
			input.checked = /*checked*/ ctx[13];
			input.disabled = /*disabled*/ ctx[14];
			attr(input, "max", /*max*/ ctx[15]);
			attr(input, "maxlength", /*maxlength*/ ctx[18]);
			attr(input, "min", /*min*/ ctx[16]);
			attr(input, "minlength", /*minlength*/ ctx[19]);
			attr(input, "step", /*step*/ ctx[17]);
			input.multiple = /*multiple*/ ctx[20];
			input.readOnly = /*readonly*/ ctx[21];
			input.required = /*required*/ ctx[22];
			attr(input, "pattern", /*pattern*/ ctx[24]);

			attr(input, "validate", input_validate_value = typeof /*validate*/ ctx[25] === "string" && /*validate*/ ctx[25].length
			? /*validate*/ ctx[25]
			: undefined);

			attr(input, "data-validate", input_data_validate_value = /*validate*/ ctx[25] === true || /*validate*/ ctx[25] === "" || /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
			? true
			: undefined);

			attr(input, "data-validate-on-blur", input_data_validate_on_blur_value = /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
			? true
			: undefined);

			attr(input, "tabindex", /*tabindex*/ ctx[27]);

			attr(input, "data-error-message", input_data_error_message_value = /*errorMessageForce*/ ctx[31]
			? undefined
			: /*errorMessage*/ ctx[30]);

			attr(input, "class", /*inputClassName*/ ctx[39]);

			input.value = input_value_value = /*type*/ ctx[1] === "datepicker" || /*type*/ ctx[1] === "colorpicker" || /*type*/ ctx[1] === "file"
			? ""
			: /*inputValue*/ ctx[37];
		},
		m(target, anchor) {
			insert(target, input, anchor);
			/*input_binding*/ ctx[62](input);

			if (!mounted) {
				dispose = [
					listen(input, "focus", /*onFocus*/ ctx[43]),
					listen(input, "blur", /*onBlur*/ ctx[44]),
					listen(input, "input", /*onInput*/ ctx[42]),
					listen(input, "change", /*onChange*/ ctx[45])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*inputStyle*/ 8388608) {
				attr(input, "style", /*inputStyle*/ ctx[23]);
			}

			if (dirty[0] & /*name*/ 4) {
				attr(input, "name", /*name*/ ctx[2]);
			}

			if (dirty[1] & /*inputType*/ 16) {
				attr(input, "type", /*inputType*/ ctx[35]);
			}

			if (dirty[0] & /*placeholder*/ 8) {
				attr(input, "placeholder", /*placeholder*/ ctx[3]);
			}

			if (dirty[0] & /*inputId*/ 16) {
				attr(input, "id", /*inputId*/ ctx[4]);
			}

			if (dirty[0] & /*size*/ 32) {
				attr(input, "size", /*size*/ ctx[5]);
			}

			if (dirty[0] & /*accept*/ 64) {
				attr(input, "accept", /*accept*/ ctx[6]);
			}

			if (dirty[0] & /*autocomplete*/ 128) {
				attr(input, "autocomplete", /*autocomplete*/ ctx[7]);
			}

			if (dirty[0] & /*autocorrect*/ 256) {
				attr(input, "autocorrect", /*autocorrect*/ ctx[8]);
			}

			if (dirty[0] & /*autocapitalize*/ 512) {
				attr(input, "autocapitalize", /*autocapitalize*/ ctx[9]);
			}

			if (dirty[0] & /*spellcheck*/ 1024) {
				attr(input, "spellcheck", /*spellcheck*/ ctx[10]);
			}

			if (dirty[0] & /*autofocus*/ 2048) {
				input.autofocus = /*autofocus*/ ctx[11];
			}

			if (dirty[0] & /*autosave*/ 4096) {
				attr(input, "autosave", /*autosave*/ ctx[12]);
			}

			if (dirty[0] & /*checked*/ 8192) {
				input.checked = /*checked*/ ctx[13];
			}

			if (dirty[0] & /*disabled*/ 16384) {
				input.disabled = /*disabled*/ ctx[14];
			}

			if (dirty[0] & /*max*/ 32768) {
				attr(input, "max", /*max*/ ctx[15]);
			}

			if (dirty[0] & /*maxlength*/ 262144) {
				attr(input, "maxlength", /*maxlength*/ ctx[18]);
			}

			if (dirty[0] & /*min*/ 65536) {
				attr(input, "min", /*min*/ ctx[16]);
			}

			if (dirty[0] & /*minlength*/ 524288) {
				attr(input, "minlength", /*minlength*/ ctx[19]);
			}

			if (dirty[0] & /*step*/ 131072) {
				attr(input, "step", /*step*/ ctx[17]);
			}

			if (dirty[0] & /*multiple*/ 1048576) {
				input.multiple = /*multiple*/ ctx[20];
			}

			if (dirty[0] & /*readonly*/ 2097152) {
				input.readOnly = /*readonly*/ ctx[21];
			}

			if (dirty[0] & /*required*/ 4194304) {
				input.required = /*required*/ ctx[22];
			}

			if (dirty[0] & /*pattern*/ 16777216) {
				attr(input, "pattern", /*pattern*/ ctx[24]);
			}

			if (dirty[0] & /*validate*/ 33554432 && input_validate_value !== (input_validate_value = typeof /*validate*/ ctx[25] === "string" && /*validate*/ ctx[25].length
			? /*validate*/ ctx[25]
			: undefined)) {
				attr(input, "validate", input_validate_value);
			}

			if (dirty[0] & /*validate, validateOnBlur*/ 100663296 && input_data_validate_value !== (input_data_validate_value = /*validate*/ ctx[25] === true || /*validate*/ ctx[25] === "" || /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
			? true
			: undefined)) {
				attr(input, "data-validate", input_data_validate_value);
			}

			if (dirty[0] & /*validateOnBlur*/ 67108864 && input_data_validate_on_blur_value !== (input_data_validate_on_blur_value = /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
			? true
			: undefined)) {
				attr(input, "data-validate-on-blur", input_data_validate_on_blur_value);
			}

			if (dirty[0] & /*tabindex*/ 134217728) {
				attr(input, "tabindex", /*tabindex*/ ctx[27]);
			}

			if (dirty[0] & /*errorMessage*/ 1073741824 | dirty[1] & /*errorMessageForce*/ 1 && input_data_error_message_value !== (input_data_error_message_value = /*errorMessageForce*/ ctx[31]
			? undefined
			: /*errorMessage*/ ctx[30])) {
				attr(input, "data-error-message", input_data_error_message_value);
			}

			if (dirty[1] & /*inputClassName*/ 256) {
				attr(input, "class", /*inputClassName*/ ctx[39]);
			}

			if (dirty[0] & /*type*/ 2 | dirty[1] & /*inputValue*/ 64 && input_value_value !== (input_value_value = /*type*/ ctx[1] === "datepicker" || /*type*/ ctx[1] === "colorpicker" || /*type*/ ctx[1] === "file"
			? ""
			: /*inputValue*/ ctx[37]) && input.value !== input_value_value) {
				input.value = input_value_value;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(input);
			/*input_binding*/ ctx[62](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (430:36) 
function create_if_block_8(ctx) {
	let texteditor;
	let current;

	const texteditor_spread_levels = [
		{
			value: typeof /*value*/ ctx[0] === "undefined"
			? ""
			: /*value*/ ctx[0]
		},
		{ resizable: /*resizable*/ ctx[28] },
		{ placeholder: /*placeholder*/ ctx[3] },
		{ onTextEditorFocus: /*onFocus*/ ctx[43] },
		{ onTextEditorBlur: /*onBlur*/ ctx[44] },
		{ onTextEditorInput: /*onInput*/ ctx[42] },
		{ onTextEditorChange: /*onChange*/ ctx[45] },
		/*textEditorParams*/ ctx[34]
	];

	let texteditor_props = {};

	for (let i = 0; i < texteditor_spread_levels.length; i += 1) {
		texteditor_props = assign(texteditor_props, texteditor_spread_levels[i]);
	}

	texteditor = new TextEditor({ props: texteditor_props });

	return {
		c() {
			create_component(texteditor.$$.fragment);
		},
		m(target, anchor) {
			mount_component(texteditor, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const texteditor_changes = (dirty[0] & /*value, resizable, placeholder*/ 268435465 | dirty[1] & /*onFocus, onBlur, onInput, onChange, textEditorParams*/ 30728)
			? get_spread_update(texteditor_spread_levels, [
					dirty[0] & /*value*/ 1 && {
						value: typeof /*value*/ ctx[0] === "undefined"
						? ""
						: /*value*/ ctx[0]
					},
					dirty[0] & /*resizable*/ 268435456 && { resizable: /*resizable*/ ctx[28] },
					dirty[0] & /*placeholder*/ 8 && { placeholder: /*placeholder*/ ctx[3] },
					dirty[1] & /*onFocus*/ 4096 && { onTextEditorFocus: /*onFocus*/ ctx[43] },
					dirty[1] & /*onBlur*/ 8192 && { onTextEditorBlur: /*onBlur*/ ctx[44] },
					dirty[1] & /*onInput*/ 2048 && { onTextEditorInput: /*onInput*/ ctx[42] },
					dirty[1] & /*onChange*/ 16384 && { onTextEditorChange: /*onChange*/ ctx[45] },
					dirty[1] & /*textEditorParams*/ 8 && get_spread_object(/*textEditorParams*/ ctx[34])
				])
			: {};

			texteditor.$set(texteditor_changes);
		},
		i(local) {
			if (current) return;
			transition_in(texteditor.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(texteditor.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(texteditor, detaching);
		}
	};
}

// (418:31) 
function create_if_block_7(ctx) {
	let range;
	let current;

	range = new Range({
			props: {
				value: /*value*/ ctx[0],
				disabled: /*disabled*/ ctx[14],
				min: /*min*/ ctx[16],
				max: /*max*/ ctx[15],
				step: /*step*/ ctx[17],
				name: /*name*/ ctx[2],
				id: /*inputId*/ ctx[4],
				input: true
			}
		});

	range.$on("rangeChange", /*onChange*/ ctx[45]);

	return {
		c() {
			create_component(range.$$.fragment);
		},
		m(target, anchor) {
			mount_component(range, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const range_changes = {};
			if (dirty[0] & /*value*/ 1) range_changes.value = /*value*/ ctx[0];
			if (dirty[0] & /*disabled*/ 16384) range_changes.disabled = /*disabled*/ ctx[14];
			if (dirty[0] & /*min*/ 65536) range_changes.min = /*min*/ ctx[16];
			if (dirty[0] & /*max*/ 32768) range_changes.max = /*max*/ ctx[15];
			if (dirty[0] & /*step*/ 131072) range_changes.step = /*step*/ ctx[17];
			if (dirty[0] & /*name*/ 4) range_changes.name = /*name*/ ctx[2];
			if (dirty[0] & /*inputId*/ 16) range_changes.id = /*inputId*/ ctx[4];
			range.$set(range_changes);
		},
		i(local) {
			if (current) return;
			transition_in(range.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(range.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(range, detaching);
		}
	};
}

// (416:32) 
function create_if_block_6(ctx) {
	let toggle;
	let current;

	toggle = new Toggle({
			props: {
				checked: /*checked*/ ctx[13],
				readonly: /*readonly*/ ctx[21],
				name: /*name*/ ctx[2],
				value: /*value*/ ctx[0],
				disabled: /*disabled*/ ctx[14],
				id: /*inputId*/ ctx[4]
			}
		});

	toggle.$on("change", /*onChange*/ ctx[45]);

	return {
		c() {
			create_component(toggle.$$.fragment);
		},
		m(target, anchor) {
			mount_component(toggle, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const toggle_changes = {};
			if (dirty[0] & /*checked*/ 8192) toggle_changes.checked = /*checked*/ ctx[13];
			if (dirty[0] & /*readonly*/ 2097152) toggle_changes.readonly = /*readonly*/ ctx[21];
			if (dirty[0] & /*name*/ 4) toggle_changes.name = /*name*/ ctx[2];
			if (dirty[0] & /*value*/ 1) toggle_changes.value = /*value*/ ctx[0];
			if (dirty[0] & /*disabled*/ 16384) toggle_changes.disabled = /*disabled*/ ctx[14];
			if (dirty[0] & /*inputId*/ 16) toggle_changes.id = /*inputId*/ ctx[4];
			toggle.$set(toggle_changes);
		},
		i(local) {
			if (current) return;
			transition_in(toggle.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(toggle.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(toggle, detaching);
		}
	};
}

// (373:34) 
function create_if_block_5(ctx) {
	let textarea;
	let textarea_validate_value;
	let textarea_data_validate_value;
	let textarea_data_validate_on_blur_value;
	let textarea_data_error_message_value;
	let mounted;
	let dispose;

	return {
		c() {
			textarea = element("textarea");
			attr(textarea, "style", /*inputStyle*/ ctx[23]);
			attr(textarea, "name", /*name*/ ctx[2]);
			attr(textarea, "placeholder", /*placeholder*/ ctx[3]);
			attr(textarea, "id", /*inputId*/ ctx[4]);
			attr(textarea, "size", /*size*/ ctx[5]);
			attr(textarea, "accept", /*accept*/ ctx[6]);
			attr(textarea, "autocomplete", /*autocomplete*/ ctx[7]);
			attr(textarea, "autocorrect", /*autocorrect*/ ctx[8]);
			attr(textarea, "autocapitalize", /*autocapitalize*/ ctx[9]);
			attr(textarea, "spellcheck", /*spellcheck*/ ctx[10]);
			textarea.autofocus = /*autofocus*/ ctx[11];
			attr(textarea, "autosave", /*autosave*/ ctx[12]);
			attr(textarea, "checked", /*checked*/ ctx[13]);
			textarea.disabled = /*disabled*/ ctx[14];
			attr(textarea, "max", /*max*/ ctx[15]);
			attr(textarea, "maxlength", /*maxlength*/ ctx[18]);
			attr(textarea, "min", /*min*/ ctx[16]);
			attr(textarea, "minlength", /*minlength*/ ctx[19]);
			attr(textarea, "step", /*step*/ ctx[17]);
			attr(textarea, "multiple", /*multiple*/ ctx[20]);
			textarea.readOnly = /*readonly*/ ctx[21];
			textarea.required = /*required*/ ctx[22];
			attr(textarea, "pattern", /*pattern*/ ctx[24]);

			attr(textarea, "validate", textarea_validate_value = typeof /*validate*/ ctx[25] === "string" && /*validate*/ ctx[25].length
			? /*validate*/ ctx[25]
			: undefined);

			attr(textarea, "data-validate", textarea_data_validate_value = /*validate*/ ctx[25] === true || /*validate*/ ctx[25] === "" || /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
			? true
			: undefined);

			attr(textarea, "data-validate-on-blur", textarea_data_validate_on_blur_value = /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
			? true
			: undefined);

			attr(textarea, "tabindex", /*tabindex*/ ctx[27]);

			attr(textarea, "data-error-message", textarea_data_error_message_value = /*errorMessageForce*/ ctx[31]
			? undefined
			: /*errorMessage*/ ctx[30]);

			attr(textarea, "class", /*inputClassName*/ ctx[39]);
			textarea.value = /*inputValue*/ ctx[37];
		},
		m(target, anchor) {
			insert(target, textarea, anchor);
			/*textarea_binding*/ ctx[61](textarea);

			if (!mounted) {
				dispose = [
					listen(textarea, "focus", /*onFocus*/ ctx[43]),
					listen(textarea, "blur", /*onBlur*/ ctx[44]),
					listen(textarea, "input", /*onInput*/ ctx[42]),
					listen(textarea, "change", /*onChange*/ ctx[45])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*inputStyle*/ 8388608) {
				attr(textarea, "style", /*inputStyle*/ ctx[23]);
			}

			if (dirty[0] & /*name*/ 4) {
				attr(textarea, "name", /*name*/ ctx[2]);
			}

			if (dirty[0] & /*placeholder*/ 8) {
				attr(textarea, "placeholder", /*placeholder*/ ctx[3]);
			}

			if (dirty[0] & /*inputId*/ 16) {
				attr(textarea, "id", /*inputId*/ ctx[4]);
			}

			if (dirty[0] & /*size*/ 32) {
				attr(textarea, "size", /*size*/ ctx[5]);
			}

			if (dirty[0] & /*accept*/ 64) {
				attr(textarea, "accept", /*accept*/ ctx[6]);
			}

			if (dirty[0] & /*autocomplete*/ 128) {
				attr(textarea, "autocomplete", /*autocomplete*/ ctx[7]);
			}

			if (dirty[0] & /*autocorrect*/ 256) {
				attr(textarea, "autocorrect", /*autocorrect*/ ctx[8]);
			}

			if (dirty[0] & /*autocapitalize*/ 512) {
				attr(textarea, "autocapitalize", /*autocapitalize*/ ctx[9]);
			}

			if (dirty[0] & /*spellcheck*/ 1024) {
				attr(textarea, "spellcheck", /*spellcheck*/ ctx[10]);
			}

			if (dirty[0] & /*autofocus*/ 2048) {
				textarea.autofocus = /*autofocus*/ ctx[11];
			}

			if (dirty[0] & /*autosave*/ 4096) {
				attr(textarea, "autosave", /*autosave*/ ctx[12]);
			}

			if (dirty[0] & /*checked*/ 8192) {
				attr(textarea, "checked", /*checked*/ ctx[13]);
			}

			if (dirty[0] & /*disabled*/ 16384) {
				textarea.disabled = /*disabled*/ ctx[14];
			}

			if (dirty[0] & /*max*/ 32768) {
				attr(textarea, "max", /*max*/ ctx[15]);
			}

			if (dirty[0] & /*maxlength*/ 262144) {
				attr(textarea, "maxlength", /*maxlength*/ ctx[18]);
			}

			if (dirty[0] & /*min*/ 65536) {
				attr(textarea, "min", /*min*/ ctx[16]);
			}

			if (dirty[0] & /*minlength*/ 524288) {
				attr(textarea, "minlength", /*minlength*/ ctx[19]);
			}

			if (dirty[0] & /*step*/ 131072) {
				attr(textarea, "step", /*step*/ ctx[17]);
			}

			if (dirty[0] & /*multiple*/ 1048576) {
				attr(textarea, "multiple", /*multiple*/ ctx[20]);
			}

			if (dirty[0] & /*readonly*/ 2097152) {
				textarea.readOnly = /*readonly*/ ctx[21];
			}

			if (dirty[0] & /*required*/ 4194304) {
				textarea.required = /*required*/ ctx[22];
			}

			if (dirty[0] & /*pattern*/ 16777216) {
				attr(textarea, "pattern", /*pattern*/ ctx[24]);
			}

			if (dirty[0] & /*validate*/ 33554432 && textarea_validate_value !== (textarea_validate_value = typeof /*validate*/ ctx[25] === "string" && /*validate*/ ctx[25].length
			? /*validate*/ ctx[25]
			: undefined)) {
				attr(textarea, "validate", textarea_validate_value);
			}

			if (dirty[0] & /*validate, validateOnBlur*/ 100663296 && textarea_data_validate_value !== (textarea_data_validate_value = /*validate*/ ctx[25] === true || /*validate*/ ctx[25] === "" || /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
			? true
			: undefined)) {
				attr(textarea, "data-validate", textarea_data_validate_value);
			}

			if (dirty[0] & /*validateOnBlur*/ 67108864 && textarea_data_validate_on_blur_value !== (textarea_data_validate_on_blur_value = /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
			? true
			: undefined)) {
				attr(textarea, "data-validate-on-blur", textarea_data_validate_on_blur_value);
			}

			if (dirty[0] & /*tabindex*/ 134217728) {
				attr(textarea, "tabindex", /*tabindex*/ ctx[27]);
			}

			if (dirty[0] & /*errorMessage*/ 1073741824 | dirty[1] & /*errorMessageForce*/ 1 && textarea_data_error_message_value !== (textarea_data_error_message_value = /*errorMessageForce*/ ctx[31]
			? undefined
			: /*errorMessage*/ ctx[30])) {
				attr(textarea, "data-error-message", textarea_data_error_message_value);
			}

			if (dirty[1] & /*inputClassName*/ 256) {
				attr(textarea, "class", /*inputClassName*/ ctx[39]);
			}

			if (dirty[1] & /*inputValue*/ 64) {
				textarea.value = /*inputValue*/ ctx[37];
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(textarea);
			/*textarea_binding*/ ctx[61](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (328:4) {#if type === 'select'}
function create_if_block_4(ctx) {
	let select;
	let select_validate_value;
	let select_data_validate_value;
	let select_data_validate_on_blur_value;
	let select_data_error_message_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[59].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[58], null);

	return {
		c() {
			select = element("select");
			if (default_slot) default_slot.c();
			attr(select, "style", /*inputStyle*/ ctx[23]);
			attr(select, "name", /*name*/ ctx[2]);
			attr(select, "placeholder", /*placeholder*/ ctx[3]);
			attr(select, "id", /*inputId*/ ctx[4]);
			attr(select, "size", /*size*/ ctx[5]);
			attr(select, "accept", /*accept*/ ctx[6]);
			attr(select, "autocomplete", /*autocomplete*/ ctx[7]);
			attr(select, "autocorrect", /*autocorrect*/ ctx[8]);
			attr(select, "autocapitalize", /*autocapitalize*/ ctx[9]);
			attr(select, "spellcheck", /*spellcheck*/ ctx[10]);
			select.autofocus = /*autofocus*/ ctx[11];
			attr(select, "autosave", /*autosave*/ ctx[12]);
			attr(select, "checked", /*checked*/ ctx[13]);
			select.disabled = /*disabled*/ ctx[14];
			attr(select, "max", /*max*/ ctx[15]);
			attr(select, "maxlength", /*maxlength*/ ctx[18]);
			attr(select, "min", /*min*/ ctx[16]);
			attr(select, "minlength", /*minlength*/ ctx[19]);
			attr(select, "step", /*step*/ ctx[17]);
			select.multiple = /*multiple*/ ctx[20];
			attr(select, "readonly", /*readonly*/ ctx[21]);
			select.required = /*required*/ ctx[22];
			attr(select, "pattern", /*pattern*/ ctx[24]);

			attr(select, "validate", select_validate_value = typeof /*validate*/ ctx[25] === "string" && /*validate*/ ctx[25].length
			? /*validate*/ ctx[25]
			: undefined);

			attr(select, "data-validate", select_data_validate_value = /*validate*/ ctx[25] === true || /*validate*/ ctx[25] === "" || /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
			? true
			: undefined);

			attr(select, "data-validate-on-blur", select_data_validate_on_blur_value = /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
			? true
			: undefined);

			attr(select, "tabindex", /*tabindex*/ ctx[27]);

			attr(select, "data-error-message", select_data_error_message_value = /*errorMessageForce*/ ctx[31]
			? undefined
			: /*errorMessage*/ ctx[30]);

			attr(select, "class", /*inputClassName*/ ctx[39]);
		},
		m(target, anchor) {
			insert(target, select, anchor);

			if (default_slot) {
				default_slot.m(select, null);
			}

			select_option(select, /*inputValue*/ ctx[37]);
			/*select_binding*/ ctx[60](select);
			current = true;

			if (!mounted) {
				dispose = [
					listen(select, "focus", /*onFocus*/ ctx[43]),
					listen(select, "blur", /*onBlur*/ ctx[44]),
					listen(select, "input", /*onInput*/ ctx[42]),
					listen(select, "change", /*onChange*/ ctx[45])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 134217728)) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[58], dirty, null, null);
				}
			}

			if (!current || dirty[0] & /*inputStyle*/ 8388608) {
				attr(select, "style", /*inputStyle*/ ctx[23]);
			}

			if (!current || dirty[0] & /*name*/ 4) {
				attr(select, "name", /*name*/ ctx[2]);
			}

			if (!current || dirty[0] & /*placeholder*/ 8) {
				attr(select, "placeholder", /*placeholder*/ ctx[3]);
			}

			if (!current || dirty[0] & /*inputId*/ 16) {
				attr(select, "id", /*inputId*/ ctx[4]);
			}

			if (!current || dirty[0] & /*size*/ 32) {
				attr(select, "size", /*size*/ ctx[5]);
			}

			if (!current || dirty[0] & /*accept*/ 64) {
				attr(select, "accept", /*accept*/ ctx[6]);
			}

			if (!current || dirty[0] & /*autocomplete*/ 128) {
				attr(select, "autocomplete", /*autocomplete*/ ctx[7]);
			}

			if (!current || dirty[0] & /*autocorrect*/ 256) {
				attr(select, "autocorrect", /*autocorrect*/ ctx[8]);
			}

			if (!current || dirty[0] & /*autocapitalize*/ 512) {
				attr(select, "autocapitalize", /*autocapitalize*/ ctx[9]);
			}

			if (!current || dirty[0] & /*spellcheck*/ 1024) {
				attr(select, "spellcheck", /*spellcheck*/ ctx[10]);
			}

			if (!current || dirty[0] & /*autofocus*/ 2048) {
				select.autofocus = /*autofocus*/ ctx[11];
			}

			if (!current || dirty[0] & /*autosave*/ 4096) {
				attr(select, "autosave", /*autosave*/ ctx[12]);
			}

			if (!current || dirty[0] & /*checked*/ 8192) {
				attr(select, "checked", /*checked*/ ctx[13]);
			}

			if (!current || dirty[0] & /*disabled*/ 16384) {
				select.disabled = /*disabled*/ ctx[14];
			}

			if (!current || dirty[0] & /*max*/ 32768) {
				attr(select, "max", /*max*/ ctx[15]);
			}

			if (!current || dirty[0] & /*maxlength*/ 262144) {
				attr(select, "maxlength", /*maxlength*/ ctx[18]);
			}

			if (!current || dirty[0] & /*min*/ 65536) {
				attr(select, "min", /*min*/ ctx[16]);
			}

			if (!current || dirty[0] & /*minlength*/ 524288) {
				attr(select, "minlength", /*minlength*/ ctx[19]);
			}

			if (!current || dirty[0] & /*step*/ 131072) {
				attr(select, "step", /*step*/ ctx[17]);
			}

			if (!current || dirty[0] & /*multiple*/ 1048576) {
				select.multiple = /*multiple*/ ctx[20];
			}

			if (!current || dirty[0] & /*readonly*/ 2097152) {
				attr(select, "readonly", /*readonly*/ ctx[21]);
			}

			if (!current || dirty[0] & /*required*/ 4194304) {
				select.required = /*required*/ ctx[22];
			}

			if (!current || dirty[0] & /*pattern*/ 16777216) {
				attr(select, "pattern", /*pattern*/ ctx[24]);
			}

			if (!current || dirty[0] & /*validate*/ 33554432 && select_validate_value !== (select_validate_value = typeof /*validate*/ ctx[25] === "string" && /*validate*/ ctx[25].length
			? /*validate*/ ctx[25]
			: undefined)) {
				attr(select, "validate", select_validate_value);
			}

			if (!current || dirty[0] & /*validate, validateOnBlur*/ 100663296 && select_data_validate_value !== (select_data_validate_value = /*validate*/ ctx[25] === true || /*validate*/ ctx[25] === "" || /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
			? true
			: undefined)) {
				attr(select, "data-validate", select_data_validate_value);
			}

			if (!current || dirty[0] & /*validateOnBlur*/ 67108864 && select_data_validate_on_blur_value !== (select_data_validate_on_blur_value = /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
			? true
			: undefined)) {
				attr(select, "data-validate-on-blur", select_data_validate_on_blur_value);
			}

			if (!current || dirty[0] & /*tabindex*/ 134217728) {
				attr(select, "tabindex", /*tabindex*/ ctx[27]);
			}

			if (!current || dirty[0] & /*errorMessage*/ 1073741824 | dirty[1] & /*errorMessageForce*/ 1 && select_data_error_message_value !== (select_data_error_message_value = /*errorMessageForce*/ ctx[31]
			? undefined
			: /*errorMessage*/ ctx[30])) {
				attr(select, "data-error-message", select_data_error_message_value);
			}

			if (!current || dirty[1] & /*inputClassName*/ 256) {
				attr(select, "class", /*inputClassName*/ ctx[39]);
			}

			if (!current || dirty[1] & /*inputValue*/ 64) {
				select_option(select, /*inputValue*/ ctx[37]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(select);
			if (default_slot) default_slot.d(detaching);
			/*select_binding*/ ctx[60](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (486:4) {#if (errorMessage || hasErrorSlots) && errorMessageForce}
function create_if_block_3(ctx) {
	let div;
	let t0;
	let t1;
	let current;
	const error_message_slot_template = /*#slots*/ ctx[59]["error-message"];
	const error_message_slot = create_slot(error_message_slot_template, ctx, /*$$scope*/ ctx[58], get_error_message_slot_context);

	return {
		c() {
			div = element("div");
			t0 = text(/*errorMessage*/ ctx[30]);
			t1 = space();
			if (error_message_slot) error_message_slot.c();
			attr(div, "class", "input-error-message");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t0);
			append(div, t1);

			if (error_message_slot) {
				error_message_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (!current || dirty[0] & /*errorMessage*/ 1073741824) set_data(t0, /*errorMessage*/ ctx[30]);

			if (error_message_slot) {
				if (error_message_slot.p && (!current || dirty[1] & /*$$scope*/ 134217728)) {
					update_slot(error_message_slot, error_message_slot_template, ctx, /*$$scope*/ ctx[58], dirty, get_error_message_slot_changes, get_error_message_slot_context);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(error_message_slot, local);
			current = true;
		},
		o(local) {
			transition_out(error_message_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (error_message_slot) error_message_slot.d(detaching);
		}
	};
}

// (492:4) {#if clearButton}
function create_if_block_2(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			attr(span, "class", "input-clear-button");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (493:4) {#if info || hasInfoSlots}
function create_if_block_1(ctx) {
	let div;
	let t0;
	let t1;
	let current;
	const info_slot_template = /*#slots*/ ctx[59].info;
	const info_slot = create_slot(info_slot_template, ctx, /*$$scope*/ ctx[58], get_info_slot_context);

	return {
		c() {
			div = element("div");
			t0 = text(/*info*/ ctx[32]);
			t1 = space();
			if (info_slot) info_slot.c();
			attr(div, "class", "input-info");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t0);
			append(div, t1);

			if (info_slot) {
				info_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (!current || dirty[1] & /*info*/ 2) set_data(t0, /*info*/ ctx[32]);

			if (info_slot) {
				if (info_slot.p && (!current || dirty[1] & /*$$scope*/ 134217728)) {
					update_slot(info_slot, info_slot_template, ctx, /*$$scope*/ ctx[58], dirty, get_info_slot_changes, get_info_slot_context);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(info_slot, local);
			current = true;
		},
		o(local) {
			transition_out(info_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (info_slot) info_slot.d(detaching);
		}
	};
}

function create_fragment(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;

	const if_block_creators = [
		create_if_block,
		create_if_block_9,
		create_if_block_10,
		create_if_block_11,
		create_if_block_12,
		create_if_block_13,
		create_else_block_1
	];

	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*wrap*/ ctx[33]) return 0;
		if (/*type*/ ctx[1] === "select") return 1;
		if (/*type*/ ctx[1] === "textarea") return 2;
		if (/*type*/ ctx[1] === "toggle") return 3;
		if (/*type*/ ctx[1] === "range") return 4;
		if (/*type*/ ctx[1] === "texteditor") return 5;
		return 6;
	}

	current_block_type_index = select_block_type(ctx, [-1]);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let inputType;
	let needsValue;
	let inputValue;
	let classes;
	let wrapClasses;
	let inputClassName;
	let hasInfoSlots;
	let hasErrorSlots;

	const omit_props_names = [
		"class","type","name","value","placeholder","inputId","size","accept","autocomplete","autocorrect","autocapitalize","spellcheck","autofocus","autosave","checked","disabled","max","min","step","maxlength","minlength","multiple","readonly","required","inputStyle","pattern","validate","validateOnBlur","onValidate","tabindex","resizable","clearButton","noFormStoreData","noStoreData","ignoreStoreData","errorMessage","errorMessageForce","info","outline","wrap","dropdown","calendarParams","colorPickerParams","textEditorParams"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = compute_slots(slots);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { type = undefined } = $$props;
	let { name = undefined } = $$props;
	let { value = undefined } = $$props;
	let { placeholder = undefined } = $$props;
	let { inputId = undefined } = $$props;
	let { size = undefined } = $$props;
	let { accept = undefined } = $$props;
	let { autocomplete = undefined } = $$props;
	let { autocorrect = undefined } = $$props;
	let { autocapitalize = undefined } = $$props;
	let { spellcheck = undefined } = $$props;
	let { autofocus = undefined } = $$props;
	let { autosave = undefined } = $$props;
	let { checked = undefined } = $$props;
	let { disabled = undefined } = $$props;
	let { max = undefined } = $$props;
	let { min = undefined } = $$props;
	let { step = undefined } = $$props;
	let { maxlength = undefined } = $$props;
	let { minlength = undefined } = $$props;
	let { multiple = undefined } = $$props;
	let { readonly = undefined } = $$props;
	let { required = undefined } = $$props;
	let { inputStyle = undefined } = $$props;
	let { pattern = undefined } = $$props;
	let { validate = undefined } = $$props;
	let { validateOnBlur = undefined } = $$props;
	let { onValidate = undefined } = $$props;
	let { tabindex = undefined } = $$props;
	let { resizable = undefined } = $$props;
	let { clearButton = undefined } = $$props;
	let { noFormStoreData = undefined } = $$props;
	let { noStoreData = undefined } = $$props;
	let { ignoreStoreData = undefined } = $$props;
	let { errorMessage = undefined } = $$props;
	let { errorMessageForce = undefined } = $$props;
	let { info = undefined } = $$props;
	let { outline = undefined } = $$props;
	let { wrap = true } = $$props;
	let { dropdown = "auto" } = $$props;
	let { calendarParams = undefined } = $$props;
	let { colorPickerParams = undefined } = $$props;
	let { textEditorParams = undefined } = $$props;

	// State
	let inputEl;

	let inputFocused = false;
	let inputInvalid = false;
	let updateInputOnDidUpdate = false;
	let f7Calendar;
	let f7ColorPicker;

	function domValue() {
		if (!inputEl) return undefined;
		return inputEl.value;
	}

	function inputHasValue() {
		if (type === "datepicker" && Array.isArray(value) && value.length === 0) {
			return false;
		}

		const domV = domValue();

		return typeof value === "undefined"
		? domV || domV === 0
		: value || value === 0;
	}

	function validateInput() {
		if (!app.f7 || !inputEl) return;
		const validity = inputEl.validity;
		if (!validity) return;

		if (!validity.valid) {
			if (onValidate) onValidate(false);

			if (inputInvalid !== true) {
				$$invalidate(57, inputInvalid = true);
			}
		} else {
			if (onValidate) onValidate(true);

			if (inputInvalid !== false) {
				$$invalidate(57, inputInvalid = false);
			}
		}
	}

	let initialWatched = false;

	function watchValue() {
		if (!initialWatched) {
			initialWatched = true;
			return;
		}

		if (type === "range" || type === "toggle") return;
		if (!app.f7) return;
		updateInputOnDidUpdate = true;

		if (f7Calendar) {
			f7Calendar.setValue(value);
		}

		if (f7ColorPicker) {
			f7ColorPicker.setValue(value);
		}
	}

	function onTextareaResize(event) {
		emit("textareaResize", [event]);
	}

	function onInputNotEmpty(event) {
		emit("inputNotEmpty", [event]);
	}

	function onInputEmpty(event) {
		emit("inputEmpty", [event]);
	}

	function onInputClear(event) {
		emit("inputClear", [event]);
	}

	function onInput(...args) {
		emit("input", [...args]);

		if (!(validateOnBlur || validateOnBlur === "") && (validate || validate === "") && inputEl) {
			validateInput(inputEl);
		}

		if (inputEl && type !== "texteditor" && type !== "colorpicker" && type !== "datepicker") {
			$$invalidate(0, value = inputEl.value);
		}
	}

	function onFocus(...args) {
		emit("focus", [...args]);
		$$invalidate(56, inputFocused = true);
	}

	function onBlur(...args) {
		emit("blur", [...args]);

		if ((validate || validate === "" || validateOnBlur || validateOnBlur === "") && inputEl) {
			validateInput();
		}

		$$invalidate(56, inputFocused = false);
	}

	function onChange(...args) {
		emit("change", [...args]);

		if (type === "texteditor") {
			emit("textEditorChange", [args[1]]);
			$$invalidate(0, value = args[1]);
		}
	}

	onMount(() => {
		f7ready(() => {
			if (type === "range" || type === "toggle") return;
			if (!inputEl) return;
			inputEl.addEventListener("input:notempty", onInputNotEmpty, false);

			if (type === "textarea" && resizable) {
				inputEl.addEventListener("textarea:resize", onTextareaResize, false);
			}

			if (clearButton) {
				inputEl.addEventListener("input:empty", onInputEmpty, false);
				inputEl.addEventListener("input:clear", onInputClear, false);
			}

			if (type === "datepicker") {
				f7Calendar = app.f7.calendar.create({
					inputEl,
					value,
					on: {
						change(calendar, calendarValue) {
							emit("calendarChange", [calendarValue]);
							$$invalidate(0, value = calendarValue);
						}
					},
					...calendarParams || {}
				});
			}

			if (type === "colorpicker") {
				f7ColorPicker = app.f7.colorPicker.create({
					inputEl,
					value,
					on: {
						change(colorPicker, colorPickerValue) {
							emit("colorpickerChange", [colorPickerValue]);
							$$invalidate(0, value = colorPickerValue);
						}
					},
					...colorPickerParams || {}
				});
			}

			app.f7.input.checkEmptyState(inputEl);

			if (!(validateOnBlur || validateOnBlur === "") && (validate || validate === "") && typeof value !== "undefined" && value !== null && value !== "") {
				setTimeout(
					() => {
						validateInput();
					},
					0
				);
			}

			if (resizable) {
				app.f7.input.resizeTextarea(inputEl);
			}
		});
	});

	afterUpdate(() => {
		if (!app.f7) return;

		if (updateInputOnDidUpdate) {
			if (!inputEl) return;
			updateInputOnDidUpdate = false;
			app.f7.input.checkEmptyState(inputEl);

			if (validate && !validateOnBlur) {
				validateInput();
			}

			if (resizable) {
				app.f7.input.resizeTextarea(inputEl);
			}
		}
	});

	onDestroy(() => {
		if (type === "range" || type === "toggle") return;
		if (!inputEl) return;
		inputEl.removeEventListener("input:notempty", onInputNotEmpty, false);

		if (type === "textarea" && resizable) {
			inputEl.removeEventListener("textarea:resize", onTextareaResize, false);
		}

		if (clearButton) {
			inputEl.removeEventListener("input:empty", onInputEmpty, false);
			inputEl.removeEventListener("input:clear", onInputClear, false);
		}

		if (f7Calendar && f7Calendar.destroy) {
			f7Calendar.destroy();
		}

		if (f7ColorPicker && f7ColorPicker.destroy) {
			f7ColorPicker.destroy();
		}

		f7Calendar = null;
		f7ColorPicker = null;
	});

	function select_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			inputEl = $$value;
			$$invalidate(36, inputEl);
		});
	}

	function textarea_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			inputEl = $$value;
			$$invalidate(36, inputEl);
		});
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			inputEl = $$value;
			$$invalidate(36, inputEl);
		});
	}

	function select_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			inputEl = $$value;
			$$invalidate(36, inputEl);
		});
	}

	function textarea_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			inputEl = $$value;
			$$invalidate(36, inputEl);
		});
	}

	function input_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			inputEl = $$value;
			$$invalidate(36, inputEl);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(81, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(46, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(47, className = $$new_props.class);
		if ("type" in $$new_props) $$invalidate(1, type = $$new_props.type);
		if ("name" in $$new_props) $$invalidate(2, name = $$new_props.name);
		if ("value" in $$new_props) $$invalidate(0, value = $$new_props.value);
		if ("placeholder" in $$new_props) $$invalidate(3, placeholder = $$new_props.placeholder);
		if ("inputId" in $$new_props) $$invalidate(4, inputId = $$new_props.inputId);
		if ("size" in $$new_props) $$invalidate(5, size = $$new_props.size);
		if ("accept" in $$new_props) $$invalidate(6, accept = $$new_props.accept);
		if ("autocomplete" in $$new_props) $$invalidate(7, autocomplete = $$new_props.autocomplete);
		if ("autocorrect" in $$new_props) $$invalidate(8, autocorrect = $$new_props.autocorrect);
		if ("autocapitalize" in $$new_props) $$invalidate(9, autocapitalize = $$new_props.autocapitalize);
		if ("spellcheck" in $$new_props) $$invalidate(10, spellcheck = $$new_props.spellcheck);
		if ("autofocus" in $$new_props) $$invalidate(11, autofocus = $$new_props.autofocus);
		if ("autosave" in $$new_props) $$invalidate(12, autosave = $$new_props.autosave);
		if ("checked" in $$new_props) $$invalidate(13, checked = $$new_props.checked);
		if ("disabled" in $$new_props) $$invalidate(14, disabled = $$new_props.disabled);
		if ("max" in $$new_props) $$invalidate(15, max = $$new_props.max);
		if ("min" in $$new_props) $$invalidate(16, min = $$new_props.min);
		if ("step" in $$new_props) $$invalidate(17, step = $$new_props.step);
		if ("maxlength" in $$new_props) $$invalidate(18, maxlength = $$new_props.maxlength);
		if ("minlength" in $$new_props) $$invalidate(19, minlength = $$new_props.minlength);
		if ("multiple" in $$new_props) $$invalidate(20, multiple = $$new_props.multiple);
		if ("readonly" in $$new_props) $$invalidate(21, readonly = $$new_props.readonly);
		if ("required" in $$new_props) $$invalidate(22, required = $$new_props.required);
		if ("inputStyle" in $$new_props) $$invalidate(23, inputStyle = $$new_props.inputStyle);
		if ("pattern" in $$new_props) $$invalidate(24, pattern = $$new_props.pattern);
		if ("validate" in $$new_props) $$invalidate(25, validate = $$new_props.validate);
		if ("validateOnBlur" in $$new_props) $$invalidate(26, validateOnBlur = $$new_props.validateOnBlur);
		if ("onValidate" in $$new_props) $$invalidate(48, onValidate = $$new_props.onValidate);
		if ("tabindex" in $$new_props) $$invalidate(27, tabindex = $$new_props.tabindex);
		if ("resizable" in $$new_props) $$invalidate(28, resizable = $$new_props.resizable);
		if ("clearButton" in $$new_props) $$invalidate(29, clearButton = $$new_props.clearButton);
		if ("noFormStoreData" in $$new_props) $$invalidate(49, noFormStoreData = $$new_props.noFormStoreData);
		if ("noStoreData" in $$new_props) $$invalidate(50, noStoreData = $$new_props.noStoreData);
		if ("ignoreStoreData" in $$new_props) $$invalidate(51, ignoreStoreData = $$new_props.ignoreStoreData);
		if ("errorMessage" in $$new_props) $$invalidate(30, errorMessage = $$new_props.errorMessage);
		if ("errorMessageForce" in $$new_props) $$invalidate(31, errorMessageForce = $$new_props.errorMessageForce);
		if ("info" in $$new_props) $$invalidate(32, info = $$new_props.info);
		if ("outline" in $$new_props) $$invalidate(52, outline = $$new_props.outline);
		if ("wrap" in $$new_props) $$invalidate(33, wrap = $$new_props.wrap);
		if ("dropdown" in $$new_props) $$invalidate(53, dropdown = $$new_props.dropdown);
		if ("calendarParams" in $$new_props) $$invalidate(54, calendarParams = $$new_props.calendarParams);
		if ("colorPickerParams" in $$new_props) $$invalidate(55, colorPickerParams = $$new_props.colorPickerParams);
		if ("textEditorParams" in $$new_props) $$invalidate(34, textEditorParams = $$new_props.textEditorParams);
		if ("$$scope" in $$new_props) $$invalidate(58, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*value*/ 1) {
			$: watchValue(value);
		}

		if ($$self.$$.dirty[0] & /*type*/ 2) {
			$: $$invalidate(35, inputType = type === "datepicker" || type === "colorpicker"
			? "text"
			: type);
		}

		if ($$self.$$.dirty[0] & /*type*/ 2) {
			$: needsValue = type !== "file" && type !== "datepicker" && type !== "colorpicker";
		}

		if ($$self.$$.dirty[0] & /*value*/ 1) {
			$: $$invalidate(37, inputValue = (() => {
				let v;

				if (typeof value !== "undefined") {
					v = value;
				} else {
					v = domValue();
				}

				if (typeof v === "undefined" || v === null) return "";
				return v;
			})());
		}

		if ($$self.$$.dirty[0] & /*resizable, errorMessage*/ 1342177280 | $$self.$$.dirty[1] & /*wrap, className, inputType, noFormStoreData, noStoreData, ignoreStoreData, errorMessageForce, inputInvalid, inputFocused*/ 102563861) {
			$: classes = classNames(!wrap && className, {
				resizable: inputType === "textarea" && resizable,
				"no-store-data": noFormStoreData || noStoreData || ignoreStoreData,
				"input-invalid": errorMessage && errorMessageForce || inputInvalid,
				"input-with-value": inputHasValue(),
				"input-focused": inputFocused
			});
		}

		$: $$invalidate(38, wrapClasses = classNames(
			className,
			"input",
			{
				"input-outline": outline,
				"input-dropdown": dropdown === "auto" ? type === "select" : dropdown,
				"input-invalid": errorMessage && errorMessageForce || inputInvalid
			},
			colorClasses($$props)
		));

		if ($$self.$$.dirty[0] & /*resizable, errorMessage*/ 1342177280 | $$self.$$.dirty[1] & /*wrap, className, inputType, noFormStoreData, noStoreData, ignoreStoreData, errorMessageForce, inputInvalid, inputFocused*/ 102563861) {
			$: $$invalidate(39, inputClassName = classNames(!wrap && className, {
				resizable: inputType === "textarea" && resizable,
				"no-store-data": noFormStoreData || noStoreData || ignoreStoreData,
				"input-invalid": errorMessage && errorMessageForce || inputInvalid,
				"input-with-value": inputHasValue(),
				"input-focused": inputFocused
			}));
		}
	};

	$: $$invalidate(40, hasInfoSlots = $$slots.info);

	// eslint-disable-next-line
	$: $$invalidate(41, hasErrorSlots = $$slots["error-message"]);

	$$props = exclude_internal_props($$props);

	return [
		value,
		type,
		name,
		placeholder,
		inputId,
		size,
		accept,
		autocomplete,
		autocorrect,
		autocapitalize,
		spellcheck,
		autofocus,
		autosave,
		checked,
		disabled,
		max,
		min,
		step,
		maxlength,
		minlength,
		multiple,
		readonly,
		required,
		inputStyle,
		pattern,
		validate,
		validateOnBlur,
		tabindex,
		resizable,
		clearButton,
		errorMessage,
		errorMessageForce,
		info,
		wrap,
		textEditorParams,
		inputType,
		inputEl,
		inputValue,
		wrapClasses,
		inputClassName,
		hasInfoSlots,
		hasErrorSlots,
		onInput,
		onFocus,
		onBlur,
		onChange,
		$$restProps,
		className,
		onValidate,
		noFormStoreData,
		noStoreData,
		ignoreStoreData,
		outline,
		dropdown,
		calendarParams,
		colorPickerParams,
		inputFocused,
		inputInvalid,
		$$scope,
		slots,
		select_binding,
		textarea_binding,
		input_binding,
		select_binding_1,
		textarea_binding_1,
		input_binding_1
	];
}

class Input extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				class: 47,
				type: 1,
				name: 2,
				value: 0,
				placeholder: 3,
				inputId: 4,
				size: 5,
				accept: 6,
				autocomplete: 7,
				autocorrect: 8,
				autocapitalize: 9,
				spellcheck: 10,
				autofocus: 11,
				autosave: 12,
				checked: 13,
				disabled: 14,
				max: 15,
				min: 16,
				step: 17,
				maxlength: 18,
				minlength: 19,
				multiple: 20,
				readonly: 21,
				required: 22,
				inputStyle: 23,
				pattern: 24,
				validate: 25,
				validateOnBlur: 26,
				onValidate: 48,
				tabindex: 27,
				resizable: 28,
				clearButton: 29,
				noFormStoreData: 49,
				noStoreData: 50,
				ignoreStoreData: 51,
				errorMessage: 30,
				errorMessageForce: 31,
				info: 32,
				outline: 52,
				wrap: 33,
				dropdown: 53,
				calendarParams: 54,
				colorPickerParams: 55,
				textEditorParams: 34
			},
			[-1, -1, -1]
		);
	}
}

export default Input;