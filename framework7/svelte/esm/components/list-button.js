/* list-button.svelte generated by Svelte v3.38.2 */
import {
	SvelteComponent,
	action_destroyer,
	append,
	assign,
	binding_callbacks,
	compute_rest_props,
	create_slot,
	detach,
	element,
	exclude_internal_props,
	get_spread_update,
	init,
	insert,
	is_function,
	listen,
	run_all,
	safe_not_equal,
	set_attributes,
	set_data,
	space,
	text as text_1,
	transition_in,
	transition_out,
	update_slot
} from "svelte/internal";

import { createEventDispatcher } from "svelte";

import {
	colorClasses,
	routerAttrs,
	routerClasses,
	actionsAttrs,
	actionsClasses
} from "../shared/mixins";

import {
	classNames,
	extend,
	plainText,
	isStringProp,
	createEmitter
} from "../shared/utils";

import { restProps } from "../shared/rest-props";
import { useTooltip } from "../shared/use-tooltip";
import { useRouteProps } from "../shared/use-route-props";

function create_fragment(ctx) {
	let li;
	let a;
	let t0_value = plainText(/*title*/ ctx[1]) + "";
	let t0;
	let t1;
	let t2_value = plainText(/*text*/ ctx[2]) + "";
	let t2;
	let t3;
	let useRouteProps_action;
	let useTooltip_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[18].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[17], null);
	let a_levels = [{ class: /*classes*/ ctx[8] }, /*attrs*/ ctx[7]];
	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	let li_levels = [{ class: /*className*/ ctx[0] }, restProps(/*$$restProps*/ ctx[10])];
	let li_data = {};

	for (let i = 0; i < li_levels.length; i += 1) {
		li_data = assign(li_data, li_levels[i]);
	}

	return {
		c() {
			li = element("li");
			a = element("a");
			t0 = text_1(t0_value);
			t1 = space();
			t2 = text_1(t2_value);
			t3 = space();
			if (default_slot) default_slot.c();
			set_attributes(a, a_data);
			set_attributes(li, li_data);
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, a);
			append(a, t0);
			append(a, t1);
			append(a, t2);
			append(a, t3);

			if (default_slot) {
				default_slot.m(a, null);
			}

			/*li_binding*/ ctx[19](li);
			current = true;

			if (!mounted) {
				dispose = [
					listen(a, "click", /*onClick*/ ctx[9]),
					action_destroyer(useRouteProps_action = useRouteProps.call(null, li, /*routeProps*/ ctx[5])),
					action_destroyer(useTooltip_action = useTooltip.call(null, li, {
						tooltip: /*tooltip*/ ctx[3],
						tooltipTrigger: /*tooltipTrigger*/ ctx[4]
					}))
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if ((!current || dirty & /*title*/ 2) && t0_value !== (t0_value = plainText(/*title*/ ctx[1]) + "")) set_data(t0, t0_value);
			if ((!current || dirty & /*text*/ 4) && t2_value !== (t2_value = plainText(/*text*/ ctx[2]) + "")) set_data(t2, t2_value);

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 131072)) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[17], dirty, null, null);
				}
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				(!current || dirty & /*classes*/ 256) && { class: /*classes*/ ctx[8] },
				dirty & /*attrs*/ 128 && /*attrs*/ ctx[7]
			]));

			set_attributes(li, li_data = get_spread_update(li_levels, [
				(!current || dirty & /*className*/ 1) && { class: /*className*/ ctx[0] },
				dirty & /*$$restProps*/ 1024 && restProps(/*$$restProps*/ ctx[10])
			]));

			if (useRouteProps_action && is_function(useRouteProps_action.update) && dirty & /*routeProps*/ 32) useRouteProps_action.update.call(null, /*routeProps*/ ctx[5]);

			if (useTooltip_action && is_function(useTooltip_action.update) && dirty & /*tooltip, tooltipTrigger*/ 24) useTooltip_action.update.call(null, {
				tooltip: /*tooltip*/ ctx[3],
				tooltipTrigger: /*tooltipTrigger*/ ctx[4]
			});
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(li);
			if (default_slot) default_slot.d(detaching);
			/*li_binding*/ ctx[19](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let hrefComputed;
	let attrs;
	let classes;

	const omit_props_names = [
		"class","title","text","tabLink","tabLinkActive","link","href","target","tooltip","tooltipTrigger","routeProps"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { title = undefined } = $$props;
	let { text = undefined } = $$props;
	let { tabLink = undefined } = $$props;
	let { tabLinkActive = false } = $$props;
	let { link = undefined } = $$props;
	let { href = undefined } = $$props;
	let { target = undefined } = $$props;
	let { tooltip = undefined } = $$props;
	let { tooltipTrigger = undefined } = $$props;
	let { routeProps = undefined } = $$props;
	let el;

	function onClick() {
		emit("click");
	}

	function li_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(6, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(21, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(0, className = $$new_props.class);
		if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
		if ("text" in $$new_props) $$invalidate(2, text = $$new_props.text);
		if ("tabLink" in $$new_props) $$invalidate(11, tabLink = $$new_props.tabLink);
		if ("tabLinkActive" in $$new_props) $$invalidate(12, tabLinkActive = $$new_props.tabLinkActive);
		if ("link" in $$new_props) $$invalidate(13, link = $$new_props.link);
		if ("href" in $$new_props) $$invalidate(14, href = $$new_props.href);
		if ("target" in $$new_props) $$invalidate(15, target = $$new_props.target);
		if ("tooltip" in $$new_props) $$invalidate(3, tooltip = $$new_props.tooltip);
		if ("tooltipTrigger" in $$new_props) $$invalidate(4, tooltipTrigger = $$new_props.tooltipTrigger);
		if ("routeProps" in $$new_props) $$invalidate(5, routeProps = $$new_props.routeProps);
		if ("$$scope" in $$new_props) $$invalidate(17, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*link, href*/ 24576) {
			$: $$invalidate(16, hrefComputed = typeof link === "boolean" && typeof href === "boolean"
			? "#"
			: link || href);
		}

		$: $$invalidate(7, attrs = extend(
			{
				href: hrefComputed,
				target,
				"data-tab": isStringProp(tabLink) && tabLink || undefined
			},
			routerAttrs($$props),
			actionsAttrs($$props)
		));

		$: $$invalidate(8, classes = classNames(
			{
				"list-button": true,
				"tab-link": tabLink || tabLink === "",
				"tab-link-active": tabLinkActive
			},
			colorClasses($$props),
			routerClasses($$props),
			actionsClasses($$props)
		));
	};

	$$props = exclude_internal_props($$props);

	return [
		className,
		title,
		text,
		tooltip,
		tooltipTrigger,
		routeProps,
		el,
		attrs,
		classes,
		onClick,
		$$restProps,
		tabLink,
		tabLinkActive,
		link,
		href,
		target,
		hrefComputed,
		$$scope,
		slots,
		li_binding
	];
}

class List_button extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			class: 0,
			title: 1,
			text: 2,
			tabLink: 11,
			tabLinkActive: 12,
			link: 13,
			href: 14,
			target: 15,
			tooltip: 3,
			tooltipTrigger: 4,
			routeProps: 5
		});
	}
}

export default List_button;