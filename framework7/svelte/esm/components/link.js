/* link.svelte generated by Svelte v3.38.2 */
import {
	SvelteComponent,
	action_destroyer,
	append,
	assign,
	binding_callbacks,
	check_outros,
	compute_rest_props,
	compute_slots,
	create_component,
	create_slot,
	destroy_component,
	detach,
	element,
	exclude_internal_props,
	get_spread_update,
	group_outros,
	init,
	insert,
	is_function,
	listen,
	mount_component,
	run_all,
	safe_not_equal,
	set_attributes,
	set_data,
	space,
	text as text_1,
	toggle_class,
	transition_in,
	transition_out,
	update_slot
} from "svelte/internal";

import { createEventDispatcher } from "svelte";

import {
	colorClasses,
	routerAttrs,
	routerClasses,
	actionsAttrs,
	actionsClasses
} from "../shared/mixins";

import {
	classNames,
	extend,
	isStringProp,
	plainText,
	createEmitter
} from "../shared/utils";

import { restProps } from "../shared/rest-props";
import { useTooltip } from "../shared/use-tooltip";
import { useSmartSelect } from "../shared/use-smart-select";
import { useRouteProps } from "../shared/use-route-props";
import { useIcon } from "../shared/use-icon";
import { getReactiveContext } from "../shared/get-reactive-context";
import UseIcon from "./use-icon";
import Badge from "./badge";

function create_if_block_2(ctx) {
	let useicon;
	let current;
	useicon = new UseIcon({ props: { icon: /*icon*/ ctx[10] } });

	return {
		c() {
			create_component(useicon.$$.fragment);
		},
		m(target, anchor) {
			mount_component(useicon, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const useicon_changes = {};
			if (dirty[0] & /*icon*/ 1024) useicon_changes.icon = /*icon*/ ctx[10];
			useicon.$set(useicon_changes);
		},
		i(local) {
			if (current) return;
			transition_in(useicon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(useicon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(useicon, detaching);
		}
	};
}

// (114:2) {#if typeof text !== 'undefined' || typeof badge !== 'undefined'}
function create_if_block(ctx) {
	let span;
	let t0_value = plainText(/*text*/ ctx[0]) + "";
	let t0;
	let t1;
	let current;
	let if_block = typeof /*badge*/ ctx[1] !== "undefined" && create_if_block_1(ctx);

	return {
		c() {
			span = element("span");
			t0 = text_1(t0_value);
			t1 = space();
			if (if_block) if_block.c();
			toggle_class(span, "tabbar-label", /*isTabbarLabel*/ ctx[6]);
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t0);
			append(span, t1);
			if (if_block) if_block.m(span, null);
			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*text*/ 1) && t0_value !== (t0_value = plainText(/*text*/ ctx[0]) + "")) set_data(t0, t0_value);

			if (typeof /*badge*/ ctx[1] !== "undefined") {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(span, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (dirty[0] & /*isTabbarLabel*/ 64) {
				toggle_class(span, "tabbar-label", /*isTabbarLabel*/ ctx[6]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span);
			if (if_block) if_block.d();
		}
	};
}

// (117:6) {#if typeof badge !== 'undefined'}
function create_if_block_1(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[2],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(badge_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 4) badge_1_changes.color = /*badgeColor*/ ctx[2];

			if (dirty[0] & /*$$scope, badge*/ 268435458) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(badge_1, detaching);
		}
	};
}

// (117:40) <Badge color={badgeColor}>
function create_default_slot(ctx) {
	let t_value = plainText(/*badge*/ ctx[1]) + "";
	let t;

	return {
		c() {
			t = text_1(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*badge*/ 2 && t_value !== (t_value = plainText(/*badge*/ ctx[1]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function create_fragment(ctx) {
	let a;
	let t0;
	let t1;
	let useTooltip_action;
	let useRouteProps_action;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*icon*/ ctx[10] && create_if_block_2(ctx);
	const default_slot_template = /*#slots*/ ctx[26].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[28], null);
	let if_block1 = (typeof /*text*/ ctx[0] !== "undefined" || typeof /*badge*/ ctx[1] !== "undefined") && create_if_block(ctx);
	let a_levels = [{ class: /*classes*/ ctx[9] }, /*attrs*/ ctx[8]];
	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	return {
		c() {
			a = element("a");
			if (if_block0) if_block0.c();
			t0 = space();
			if (default_slot) default_slot.c();
			t1 = space();
			if (if_block1) if_block1.c();
			set_attributes(a, a_data);
		},
		m(target, anchor) {
			insert(target, a, anchor);
			if (if_block0) if_block0.m(a, null);
			append(a, t0);

			if (default_slot) {
				default_slot.m(a, null);
			}

			append(a, t1);
			if (if_block1) if_block1.m(a, null);
			/*a_binding*/ ctx[27](a);
			current = true;

			if (!mounted) {
				dispose = [
					listen(a, "click", /*onClick*/ ctx[11]),
					action_destroyer(useTooltip_action = useTooltip.call(null, a, {
						tooltip: /*tooltip*/ ctx[3],
						tooltipTrigger: /*tooltipTrigger*/ ctx[4]
					})),
					action_destroyer(useRouteProps_action = useRouteProps.call(null, a, /*routeProps*/ ctx[5]))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[10]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*icon*/ 1024) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(a, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[0] & /*$$scope*/ 268435456)) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[28], dirty, null, null);
				}
			}

			if (typeof /*text*/ ctx[0] !== "undefined" || typeof /*badge*/ ctx[1] !== "undefined") {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*text, badge*/ 3) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(a, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				(!current || dirty[0] & /*classes*/ 512) && { class: /*classes*/ ctx[9] },
				dirty[0] & /*attrs*/ 256 && /*attrs*/ ctx[8]
			]));

			if (useTooltip_action && is_function(useTooltip_action.update) && dirty[0] & /*tooltip, tooltipTrigger*/ 24) useTooltip_action.update.call(null, {
				tooltip: /*tooltip*/ ctx[3],
				tooltipTrigger: /*tooltipTrigger*/ ctx[4]
			});

			if (useRouteProps_action && is_function(useRouteProps_action.update) && dirty[0] & /*routeProps*/ 32) useRouteProps_action.update.call(null, /*routeProps*/ ctx[5]);
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(default_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(default_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(a);
			if (if_block0) if_block0.d();
			if (default_slot) default_slot.d(detaching);
			if (if_block1) if_block1.d();
			/*a_binding*/ ctx[27](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let isTabbarLabel;
	let hrefComputed;
	let attrs;
	let hasDefaultSlots;
	let iconOnlyComputed;
	let classes;
	let icon;

	const omit_props_names = [
		"class","noLinkClass","text","tabLink","tabLinkActive","tabbarLabel","iconOnly","badge","badgeColor","href","target","tooltip","tooltipTrigger","routeProps","smartSelect","smartSelectParams"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = compute_slots(slots);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { noLinkClass = false } = $$props;
	let { text = undefined } = $$props;
	let { tabLink = undefined } = $$props;
	let { tabLinkActive = false } = $$props;
	let { tabbarLabel = false } = $$props;
	let { iconOnly = false } = $$props;
	let { badge = undefined } = $$props;
	let { badgeColor = undefined } = $$props;
	let { href = "#" } = $$props;
	let { target = undefined } = $$props;
	let { tooltip = undefined } = $$props;
	let { tooltipTrigger = undefined } = $$props;
	let { routeProps = undefined } = $$props;
	let { smartSelect = false } = $$props;
	let { smartSelectParams = undefined } = $$props;
	let el;
	let f7SmartSelect;

	let TabbarContext = getReactiveContext("TabbarContext", newValue => {
		$$invalidate(22, TabbarContext = newValue);
	}) || {};

	function onClick() {
		emit("click");
	}

	useSmartSelect(
		{ smartSelect, smartSelectParams },
		instance => {
			f7SmartSelect = instance;
		},
		() => el
	);

	function a_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(7, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(31, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(32, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(12, className = $$new_props.class);
		if ("noLinkClass" in $$new_props) $$invalidate(13, noLinkClass = $$new_props.noLinkClass);
		if ("text" in $$new_props) $$invalidate(0, text = $$new_props.text);
		if ("tabLink" in $$new_props) $$invalidate(14, tabLink = $$new_props.tabLink);
		if ("tabLinkActive" in $$new_props) $$invalidate(15, tabLinkActive = $$new_props.tabLinkActive);
		if ("tabbarLabel" in $$new_props) $$invalidate(16, tabbarLabel = $$new_props.tabbarLabel);
		if ("iconOnly" in $$new_props) $$invalidate(17, iconOnly = $$new_props.iconOnly);
		if ("badge" in $$new_props) $$invalidate(1, badge = $$new_props.badge);
		if ("badgeColor" in $$new_props) $$invalidate(2, badgeColor = $$new_props.badgeColor);
		if ("href" in $$new_props) $$invalidate(18, href = $$new_props.href);
		if ("target" in $$new_props) $$invalidate(19, target = $$new_props.target);
		if ("tooltip" in $$new_props) $$invalidate(3, tooltip = $$new_props.tooltip);
		if ("tooltipTrigger" in $$new_props) $$invalidate(4, tooltipTrigger = $$new_props.tooltipTrigger);
		if ("routeProps" in $$new_props) $$invalidate(5, routeProps = $$new_props.routeProps);
		if ("smartSelect" in $$new_props) $$invalidate(20, smartSelect = $$new_props.smartSelect);
		if ("smartSelectParams" in $$new_props) $$invalidate(21, smartSelectParams = $$new_props.smartSelectParams);
		if ("$$scope" in $$new_props) $$invalidate(28, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*tabbarLabel, TabbarContext*/ 4259840) {
			$: $$invalidate(6, isTabbarLabel = tabbarLabel || TabbarContext.tabbarHasLabels);
		}

		if ($$self.$$.dirty[0] & /*href*/ 262144) {
			$: $$invalidate(23, hrefComputed = href === true ? "#" : href || undefined);
		}

		$: $$invalidate(8, attrs = extend(
			{
				href: hrefComputed,
				target,
				"data-tab": isStringProp(tabLink) && tabLink || undefined,
				...restProps($$restProps)
			},
			routerAttrs($$props),
			actionsAttrs($$props)
		));

		if ($$self.$$.dirty[0] & /*iconOnly, text, hasDefaultSlots*/ 16908289) {
			$: $$invalidate(25, iconOnlyComputed = iconOnly || !text && !hasDefaultSlots);
		}

		$: $$invalidate(9, classes = classNames(
			className,
			{
				link: !(noLinkClass || isTabbarLabel),
				"icon-only": iconOnlyComputed,
				"tab-link": tabLink || tabLink === "",
				"tab-link-active": tabLinkActive,
				"smart-select": smartSelect
			},
			colorClasses($$props),
			routerClasses($$props),
			actionsClasses($$props)
		));

		$: $$invalidate(10, icon = useIcon($$props));
	};

	$: $$invalidate(24, hasDefaultSlots = $$slots.default);
	$$props = exclude_internal_props($$props);

	return [
		text,
		badge,
		badgeColor,
		tooltip,
		tooltipTrigger,
		routeProps,
		isTabbarLabel,
		el,
		attrs,
		classes,
		icon,
		onClick,
		className,
		noLinkClass,
		tabLink,
		tabLinkActive,
		tabbarLabel,
		iconOnly,
		href,
		target,
		smartSelect,
		smartSelectParams,
		TabbarContext,
		hrefComputed,
		hasDefaultSlots,
		iconOnlyComputed,
		slots,
		a_binding,
		$$scope
	];
}

class Link extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				class: 12,
				noLinkClass: 13,
				text: 0,
				tabLink: 14,
				tabLinkActive: 15,
				tabbarLabel: 16,
				iconOnly: 17,
				badge: 1,
				badgeColor: 2,
				href: 18,
				target: 19,
				tooltip: 3,
				tooltipTrigger: 4,
				routeProps: 5,
				smartSelect: 20,
				smartSelectParams: 21
			},
			[-1, -1]
		);
	}
}

export default Link;