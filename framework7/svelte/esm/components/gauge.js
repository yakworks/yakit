/* gauge.svelte generated by Svelte v3.38.2 */
import {
	SvelteComponent,
	append,
	assign,
	attr,
	compute_rest_props,
	detach,
	element,
	empty,
	exclude_internal_props,
	get_spread_update,
	init,
	insert,
	noop,
	safe_not_equal,
	set_attributes,
	set_data,
	svg_element,
	text
} from "svelte/internal";

import { classNames } from "../shared/utils";
import { restProps } from "../shared/rest-props";

function create_if_block_4(ctx) {
	let path0;
	let path0_d_value;
	let path0_fill_value;
	let path1;
	let path1_d_value;
	let path1_stroke_dasharray_value;
	let path1_stroke_dashoffset_value;
	let path1_fill_value;

	return {
		c() {
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "class", "gauge-back-semi");
			attr(path0, "d", path0_d_value = `M${/*size*/ ctx[0] - /*borderWidth*/ ctx[4] / 2},${/*size*/ ctx[0] / 2} a1,1 0 0,0 -${/*size*/ ctx[0] - /*borderWidth*/ ctx[4]},0`);
			attr(path0, "stroke", /*borderBgColor*/ ctx[2]);
			attr(path0, "stroke-width", /*borderWidth*/ ctx[4]);
			attr(path0, "fill", path0_fill_value = /*bgColor*/ ctx[1] || "none");
			attr(path1, "class", "gauge-front-semi");
			attr(path1, "d", path1_d_value = `M${/*size*/ ctx[0] - /*borderWidth*/ ctx[4] / 2},${/*size*/ ctx[0] / 2} a1,1 0 0,0 -${/*size*/ ctx[0] - /*borderWidth*/ ctx[4]},0`);
			attr(path1, "stroke", /*borderColor*/ ctx[3]);
			attr(path1, "stroke-width", /*borderWidth*/ ctx[4]);
			attr(path1, "stroke-dasharray", path1_stroke_dasharray_value = /*length*/ ctx[16] / 2);
			attr(path1, "stroke-dashoffset", path1_stroke_dashoffset_value = /*length*/ ctx[16] / 2 * (1 + /*progress*/ ctx[17]));

			attr(path1, "fill", path1_fill_value = /*borderBgColor*/ ctx[2]
			? "none"
			: /*bgColor*/ ctx[1] || "none");
		},
		m(target, anchor) {
			insert(target, path0, anchor);
			insert(target, path1, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*size, borderWidth*/ 17 && path0_d_value !== (path0_d_value = `M${/*size*/ ctx[0] - /*borderWidth*/ ctx[4] / 2},${/*size*/ ctx[0] / 2} a1,1 0 0,0 -${/*size*/ ctx[0] - /*borderWidth*/ ctx[4]},0`)) {
				attr(path0, "d", path0_d_value);
			}

			if (dirty & /*borderBgColor*/ 4) {
				attr(path0, "stroke", /*borderBgColor*/ ctx[2]);
			}

			if (dirty & /*borderWidth*/ 16) {
				attr(path0, "stroke-width", /*borderWidth*/ ctx[4]);
			}

			if (dirty & /*bgColor*/ 2 && path0_fill_value !== (path0_fill_value = /*bgColor*/ ctx[1] || "none")) {
				attr(path0, "fill", path0_fill_value);
			}

			if (dirty & /*size, borderWidth*/ 17 && path1_d_value !== (path1_d_value = `M${/*size*/ ctx[0] - /*borderWidth*/ ctx[4] / 2},${/*size*/ ctx[0] / 2} a1,1 0 0,0 -${/*size*/ ctx[0] - /*borderWidth*/ ctx[4]},0`)) {
				attr(path1, "d", path1_d_value);
			}

			if (dirty & /*borderColor*/ 8) {
				attr(path1, "stroke", /*borderColor*/ ctx[3]);
			}

			if (dirty & /*borderWidth*/ 16) {
				attr(path1, "stroke-width", /*borderWidth*/ ctx[4]);
			}

			if (dirty & /*length*/ 65536 && path1_stroke_dasharray_value !== (path1_stroke_dasharray_value = /*length*/ ctx[16] / 2)) {
				attr(path1, "stroke-dasharray", path1_stroke_dasharray_value);
			}

			if (dirty & /*length, progress*/ 196608 && path1_stroke_dashoffset_value !== (path1_stroke_dashoffset_value = /*length*/ ctx[16] / 2 * (1 + /*progress*/ ctx[17]))) {
				attr(path1, "stroke-dashoffset", path1_stroke_dashoffset_value);
			}

			if (dirty & /*borderBgColor, bgColor*/ 6 && path1_fill_value !== (path1_fill_value = /*borderBgColor*/ ctx[2]
			? "none"
			: /*bgColor*/ ctx[1] || "none")) {
				attr(path1, "fill", path1_fill_value);
			}
		},
		d(detaching) {
			if (detaching) detach(path0);
			if (detaching) detach(path1);
		}
	};
}

// (54:4) {#if !semiCircle}
function create_if_block_2(ctx) {
	let circle;
	let circle_transform_value;
	let circle_stroke_dashoffset_value;
	let circle_fill_value;
	let circle_cx_value;
	let circle_cy_value;
	let if_block = /*borderBgColor*/ ctx[2] && create_if_block_3(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			circle = svg_element("circle");
			attr(circle, "class", "gauge-front-circle");
			attr(circle, "transform", circle_transform_value = `rotate(-90 ${/*size*/ ctx[0] / 2} ${/*size*/ ctx[0] / 2})`);
			attr(circle, "stroke", /*borderColor*/ ctx[3]);
			attr(circle, "stroke-width", /*borderWidth*/ ctx[4]);
			attr(circle, "stroke-dasharray", /*length*/ ctx[16]);
			attr(circle, "stroke-dashoffset", circle_stroke_dashoffset_value = /*length*/ ctx[16] * (1 - /*progress*/ ctx[17]));

			attr(circle, "fill", circle_fill_value = /*borderBgColor*/ ctx[2]
			? "none"
			: /*bgColor*/ ctx[1] || "none");

			attr(circle, "cx", circle_cx_value = /*size*/ ctx[0] / 2);
			attr(circle, "cy", circle_cy_value = /*size*/ ctx[0] / 2);
			attr(circle, "r", /*radius*/ ctx[13]);
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, circle, anchor);
		},
		p(ctx, dirty) {
			if (/*borderBgColor*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_3(ctx);
					if_block.c();
					if_block.m(circle.parentNode, circle);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*size*/ 1 && circle_transform_value !== (circle_transform_value = `rotate(-90 ${/*size*/ ctx[0] / 2} ${/*size*/ ctx[0] / 2})`)) {
				attr(circle, "transform", circle_transform_value);
			}

			if (dirty & /*borderColor*/ 8) {
				attr(circle, "stroke", /*borderColor*/ ctx[3]);
			}

			if (dirty & /*borderWidth*/ 16) {
				attr(circle, "stroke-width", /*borderWidth*/ ctx[4]);
			}

			if (dirty & /*length*/ 65536) {
				attr(circle, "stroke-dasharray", /*length*/ ctx[16]);
			}

			if (dirty & /*length, progress*/ 196608 && circle_stroke_dashoffset_value !== (circle_stroke_dashoffset_value = /*length*/ ctx[16] * (1 - /*progress*/ ctx[17]))) {
				attr(circle, "stroke-dashoffset", circle_stroke_dashoffset_value);
			}

			if (dirty & /*borderBgColor, bgColor*/ 6 && circle_fill_value !== (circle_fill_value = /*borderBgColor*/ ctx[2]
			? "none"
			: /*bgColor*/ ctx[1] || "none")) {
				attr(circle, "fill", circle_fill_value);
			}

			if (dirty & /*size*/ 1 && circle_cx_value !== (circle_cx_value = /*size*/ ctx[0] / 2)) {
				attr(circle, "cx", circle_cx_value);
			}

			if (dirty & /*size*/ 1 && circle_cy_value !== (circle_cy_value = /*size*/ ctx[0] / 2)) {
				attr(circle, "cy", circle_cy_value);
			}

			if (dirty & /*radius*/ 8192) {
				attr(circle, "r", /*radius*/ ctx[13]);
			}
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(circle);
		}
	};
}

// (55:6) {#if borderBgColor}
function create_if_block_3(ctx) {
	let circle;
	let circle_fill_value;
	let circle_cx_value;
	let circle_cy_value;

	return {
		c() {
			circle = svg_element("circle");
			attr(circle, "class", "gauge-back-circle");
			attr(circle, "stroke", /*borderBgColor*/ ctx[2]);
			attr(circle, "stroke-width", /*borderWidth*/ ctx[4]);
			attr(circle, "fill", circle_fill_value = /*bgColor*/ ctx[1] || "none");
			attr(circle, "cx", circle_cx_value = /*size*/ ctx[0] / 2);
			attr(circle, "cy", circle_cy_value = /*size*/ ctx[0] / 2);
			attr(circle, "r", /*radius*/ ctx[13]);
		},
		m(target, anchor) {
			insert(target, circle, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*borderBgColor*/ 4) {
				attr(circle, "stroke", /*borderBgColor*/ ctx[2]);
			}

			if (dirty & /*borderWidth*/ 16) {
				attr(circle, "stroke-width", /*borderWidth*/ ctx[4]);
			}

			if (dirty & /*bgColor*/ 2 && circle_fill_value !== (circle_fill_value = /*bgColor*/ ctx[1] || "none")) {
				attr(circle, "fill", circle_fill_value);
			}

			if (dirty & /*size*/ 1 && circle_cx_value !== (circle_cx_value = /*size*/ ctx[0] / 2)) {
				attr(circle, "cx", circle_cx_value);
			}

			if (dirty & /*size*/ 1 && circle_cy_value !== (circle_cy_value = /*size*/ ctx[0] / 2)) {
				attr(circle, "cy", circle_cy_value);
			}

			if (dirty & /*radius*/ 8192) {
				attr(circle, "r", /*radius*/ ctx[13]);
			}
		},
		d(detaching) {
			if (detaching) detach(circle);
		}
	};
}

// (77:4) {#if valueText}
function create_if_block_1(ctx) {
	let text_1;
	let t;
	let text_1_y_value;
	let text_1_dy_value;
	let text_1_dominant_baseline_value;

	return {
		c() {
			text_1 = svg_element("text");
			t = text(/*valueText*/ ctx[5]);
			attr(text_1, "class", "gauge-value-text");
			attr(text_1, "x", "50%");
			attr(text_1, "y", text_1_y_value = /*semiCircle*/ ctx[15] ? "100%" : "50%");
			attr(text_1, "font-weight", /*valueFontWeight*/ ctx[8]);
			attr(text_1, "font-size", /*valueFontSize*/ ctx[7]);
			attr(text_1, "fill", /*valueTextColor*/ ctx[6]);

			attr(text_1, "dy", text_1_dy_value = /*semiCircle*/ ctx[15]
			? /*labelText*/ ctx[9]
				? -/*labelFontSize*/ ctx[11] - 15
				: -5
			: 0);

			attr(text_1, "text-anchor", "middle");
			attr(text_1, "dominant-baseline", text_1_dominant_baseline_value = !/*semiCircle*/ ctx[15] ? "middle" : null);
		},
		m(target, anchor) {
			insert(target, text_1, anchor);
			append(text_1, t);
		},
		p(ctx, dirty) {
			if (dirty & /*valueText*/ 32) set_data(t, /*valueText*/ ctx[5]);

			if (dirty & /*semiCircle*/ 32768 && text_1_y_value !== (text_1_y_value = /*semiCircle*/ ctx[15] ? "100%" : "50%")) {
				attr(text_1, "y", text_1_y_value);
			}

			if (dirty & /*valueFontWeight*/ 256) {
				attr(text_1, "font-weight", /*valueFontWeight*/ ctx[8]);
			}

			if (dirty & /*valueFontSize*/ 128) {
				attr(text_1, "font-size", /*valueFontSize*/ ctx[7]);
			}

			if (dirty & /*valueTextColor*/ 64) {
				attr(text_1, "fill", /*valueTextColor*/ ctx[6]);
			}

			if (dirty & /*semiCircle, labelText, labelFontSize*/ 35328 && text_1_dy_value !== (text_1_dy_value = /*semiCircle*/ ctx[15]
			? /*labelText*/ ctx[9]
				? -/*labelFontSize*/ ctx[11] - 15
				: -5
			: 0)) {
				attr(text_1, "dy", text_1_dy_value);
			}

			if (dirty & /*semiCircle*/ 32768 && text_1_dominant_baseline_value !== (text_1_dominant_baseline_value = !/*semiCircle*/ ctx[15] ? "middle" : null)) {
				attr(text_1, "dominant-baseline", text_1_dominant_baseline_value);
			}
		},
		d(detaching) {
			if (detaching) detach(text_1);
		}
	};
}

// (91:4) {#if labelText}
function create_if_block(ctx) {
	let text_1;
	let t;
	let text_1_y_value;
	let text_1_dy_value;
	let text_1_dominant_baseline_value;

	return {
		c() {
			text_1 = svg_element("text");
			t = text(/*labelText*/ ctx[9]);
			attr(text_1, "class", "gauge-label-text");
			attr(text_1, "x", "50%");
			attr(text_1, "y", text_1_y_value = /*semiCircle*/ ctx[15] ? "100%" : "50%");
			attr(text_1, "font-weight", /*labelFontWeight*/ ctx[12]);
			attr(text_1, "font-size", /*labelFontSize*/ ctx[11]);
			attr(text_1, "fill", /*labelTextColor*/ ctx[10]);

			attr(text_1, "dy", text_1_dy_value = /*semiCircle*/ ctx[15]
			? -5
			: /*valueText*/ ctx[5]
				? /*valueFontSize*/ ctx[7] / 2 + 10
				: 0);

			attr(text_1, "text-anchor", "middle");
			attr(text_1, "dominant-baseline", text_1_dominant_baseline_value = !/*semiCircle*/ ctx[15] ? "middle" : null);
		},
		m(target, anchor) {
			insert(target, text_1, anchor);
			append(text_1, t);
		},
		p(ctx, dirty) {
			if (dirty & /*labelText*/ 512) set_data(t, /*labelText*/ ctx[9]);

			if (dirty & /*semiCircle*/ 32768 && text_1_y_value !== (text_1_y_value = /*semiCircle*/ ctx[15] ? "100%" : "50%")) {
				attr(text_1, "y", text_1_y_value);
			}

			if (dirty & /*labelFontWeight*/ 4096) {
				attr(text_1, "font-weight", /*labelFontWeight*/ ctx[12]);
			}

			if (dirty & /*labelFontSize*/ 2048) {
				attr(text_1, "font-size", /*labelFontSize*/ ctx[11]);
			}

			if (dirty & /*labelTextColor*/ 1024) {
				attr(text_1, "fill", /*labelTextColor*/ ctx[10]);
			}

			if (dirty & /*semiCircle, valueText, valueFontSize*/ 32928 && text_1_dy_value !== (text_1_dy_value = /*semiCircle*/ ctx[15]
			? -5
			: /*valueText*/ ctx[5]
				? /*valueFontSize*/ ctx[7] / 2 + 10
				: 0)) {
				attr(text_1, "dy", text_1_dy_value);
			}

			if (dirty & /*semiCircle*/ 32768 && text_1_dominant_baseline_value !== (text_1_dominant_baseline_value = !/*semiCircle*/ ctx[15] ? "middle" : null)) {
				attr(text_1, "dominant-baseline", text_1_dominant_baseline_value);
			}
		},
		d(detaching) {
			if (detaching) detach(text_1);
		}
	};
}

function create_fragment(ctx) {
	let div;
	let svg;
	let if_block0_anchor;
	let if_block1_anchor;
	let if_block2_anchor;
	let svg_width_value;
	let svg_height_value;
	let svg_viewBox_value;
	let if_block0 = /*semiCircle*/ ctx[15] && create_if_block_4(ctx);
	let if_block1 = !/*semiCircle*/ ctx[15] && create_if_block_2(ctx);
	let if_block2 = /*valueText*/ ctx[5] && create_if_block_1(ctx);
	let if_block3 = /*labelText*/ ctx[9] && create_if_block(ctx);
	let div_levels = [{ class: /*classes*/ ctx[14] }, restProps(/*$$restProps*/ ctx[18])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			svg = svg_element("svg");
			if (if_block0) if_block0.c();
			if_block0_anchor = empty();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
			if (if_block2) if_block2.c();
			if_block2_anchor = empty();
			if (if_block3) if_block3.c();
			attr(svg, "class", "gauge-svg");
			attr(svg, "width", svg_width_value = `${/*size*/ ctx[0]}px`);

			attr(svg, "height", svg_height_value = `${/*semiCircle*/ ctx[15]
			? /*size*/ ctx[0] / 2
			: /*size*/ ctx[0]}px`);

			attr(svg, "viewBox", svg_viewBox_value = `0 0 ${/*size*/ ctx[0]} ${/*semiCircle*/ ctx[15]
			? /*size*/ ctx[0] / 2
			: /*size*/ ctx[0]}`);

			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, svg);
			if (if_block0) if_block0.m(svg, null);
			append(svg, if_block0_anchor);
			if (if_block1) if_block1.m(svg, null);
			append(svg, if_block1_anchor);
			if (if_block2) if_block2.m(svg, null);
			append(svg, if_block2_anchor);
			if (if_block3) if_block3.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (/*semiCircle*/ ctx[15]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_4(ctx);
					if_block0.c();
					if_block0.m(svg, if_block0_anchor);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (!/*semiCircle*/ ctx[15]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_2(ctx);
					if_block1.c();
					if_block1.m(svg, if_block1_anchor);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*valueText*/ ctx[5]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_1(ctx);
					if_block2.c();
					if_block2.m(svg, if_block2_anchor);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (/*labelText*/ ctx[9]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block(ctx);
					if_block3.c();
					if_block3.m(svg, null);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			if (dirty & /*size*/ 1 && svg_width_value !== (svg_width_value = `${/*size*/ ctx[0]}px`)) {
				attr(svg, "width", svg_width_value);
			}

			if (dirty & /*semiCircle, size*/ 32769 && svg_height_value !== (svg_height_value = `${/*semiCircle*/ ctx[15]
			? /*size*/ ctx[0] / 2
			: /*size*/ ctx[0]}px`)) {
				attr(svg, "height", svg_height_value);
			}

			if (dirty & /*size, semiCircle*/ 32769 && svg_viewBox_value !== (svg_viewBox_value = `0 0 ${/*size*/ ctx[0]} ${/*semiCircle*/ ctx[15]
			? /*size*/ ctx[0] / 2
			: /*size*/ ctx[0]}`)) {
				attr(svg, "viewBox", svg_viewBox_value);
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*classes*/ 16384 && { class: /*classes*/ ctx[14] },
				dirty & /*$$restProps*/ 262144 && restProps(/*$$restProps*/ ctx[18])
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let classes;
	let semiCircle;
	let radius;
	let length;
	let progress;

	const omit_props_names = [
		"class","type","value","size","bgColor","borderBgColor","borderColor","borderWidth","valueText","valueTextColor","valueFontSize","valueFontWeight","labelText","labelTextColor","labelFontSize","labelFontWeight"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { class: className = undefined } = $$props;
	let { type = "circle" } = $$props;
	let { value = 0 } = $$props;
	let { size = 200 } = $$props;
	let { bgColor = "transparent" } = $$props;
	let { borderBgColor = "#eeeeee" } = $$props;
	let { borderColor = "#000000" } = $$props;
	let { borderWidth = 10 } = $$props;
	let { valueText = undefined } = $$props;
	let { valueTextColor = "#000000" } = $$props;
	let { valueFontSize = 31 } = $$props;
	let { valueFontWeight = 500 } = $$props;
	let { labelText = undefined } = $$props;
	let { labelTextColor = "#888888" } = $$props;
	let { labelFontSize = 14 } = $$props;
	let { labelFontWeight = 400 } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(18, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(19, className = $$new_props.class);
		if ("type" in $$new_props) $$invalidate(20, type = $$new_props.type);
		if ("value" in $$new_props) $$invalidate(21, value = $$new_props.value);
		if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
		if ("bgColor" in $$new_props) $$invalidate(1, bgColor = $$new_props.bgColor);
		if ("borderBgColor" in $$new_props) $$invalidate(2, borderBgColor = $$new_props.borderBgColor);
		if ("borderColor" in $$new_props) $$invalidate(3, borderColor = $$new_props.borderColor);
		if ("borderWidth" in $$new_props) $$invalidate(4, borderWidth = $$new_props.borderWidth);
		if ("valueText" in $$new_props) $$invalidate(5, valueText = $$new_props.valueText);
		if ("valueTextColor" in $$new_props) $$invalidate(6, valueTextColor = $$new_props.valueTextColor);
		if ("valueFontSize" in $$new_props) $$invalidate(7, valueFontSize = $$new_props.valueFontSize);
		if ("valueFontWeight" in $$new_props) $$invalidate(8, valueFontWeight = $$new_props.valueFontWeight);
		if ("labelText" in $$new_props) $$invalidate(9, labelText = $$new_props.labelText);
		if ("labelTextColor" in $$new_props) $$invalidate(10, labelTextColor = $$new_props.labelTextColor);
		if ("labelFontSize" in $$new_props) $$invalidate(11, labelFontSize = $$new_props.labelFontSize);
		if ("labelFontWeight" in $$new_props) $$invalidate(12, labelFontWeight = $$new_props.labelFontWeight);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 524288) {
			$: $$invalidate(14, classes = classNames(className, "gauge"));
		}

		if ($$self.$$.dirty & /*type*/ 1048576) {
			$: $$invalidate(15, semiCircle = type === "semicircle");
		}

		if ($$self.$$.dirty & /*size, borderWidth*/ 17) {
			$: $$invalidate(13, radius = size / 2 - borderWidth / 2);
		}

		if ($$self.$$.dirty & /*radius*/ 8192) {
			$: $$invalidate(16, length = 2 * Math.PI * radius);
		}

		if ($$self.$$.dirty & /*value*/ 2097152) {
			$: $$invalidate(17, progress = Math.max(Math.min(value, 1), 0));
		}
	};

	return [
		size,
		bgColor,
		borderBgColor,
		borderColor,
		borderWidth,
		valueText,
		valueTextColor,
		valueFontSize,
		valueFontWeight,
		labelText,
		labelTextColor,
		labelFontSize,
		labelFontWeight,
		radius,
		classes,
		semiCircle,
		length,
		progress,
		$$restProps,
		className,
		type,
		value
	];
}

class Gauge extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			class: 19,
			type: 20,
			value: 21,
			size: 0,
			bgColor: 1,
			borderBgColor: 2,
			borderColor: 3,
			borderWidth: 4,
			valueText: 5,
			valueTextColor: 6,
			valueFontSize: 7,
			valueFontWeight: 8,
			labelText: 9,
			labelTextColor: 10,
			labelFontSize: 11,
			labelFontWeight: 12
		});
	}
}

export default Gauge;