/* view.svelte generated by Svelte v3.38.2 */
import {
	SvelteComponent,
	append,
	assign,
	attr,
	binding_callbacks,
	check_outros,
	create_component,
	create_slot,
	destroy_component,
	detach,
	element,
	empty,
	exclude_internal_props,
	get_spread_object,
	get_spread_update,
	group_outros,
	init as init_1,
	insert,
	mount_component,
	outro_and_destroy_block,
	safe_not_equal,
	space,
	transition_in,
	transition_out,
	update_keyed_each,
	update_slot
} from "svelte/internal";

import {
	onMount,
	onDestroy,
	afterUpdate,
	createEventDispatcher,
	tick
} from "svelte";

import { app, f7ready } from "../shared/f7";
import { colorClasses } from "../shared/mixins";

import {
	classNames,
	noUndefinedProps,
	createEmitter,
	getRouterId
} from "../shared/utils";

import { getRouterInitialComponent } from "../shared/get-router-initial-component";
import { useTab } from "../shared/use-tab";
import RouterContextProvider from "./router-context-provider";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[29] = list[i];
	return child_ctx;
}

const get_default_slot_changes = dirty => ({ view: dirty[0] & /*f7View*/ 8 });
const get_default_slot_context = ctx => ({ view: /*f7View*/ ctx[3] });

// (194:4) <RouterContextProvider route={page.props.f7route} router={page.props.f7router}>
function create_default_slot(ctx) {
	let switch_instance;
	let t;
	let current;
	const switch_instance_spread_levels = [/*page*/ ctx[29].props];
	var switch_value = /*page*/ ctx[29].component;

	function switch_props(ctx) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return { props: switch_instance_props };
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
	}

	return {
		c() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			t = space();
		},
		m(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert(target, t, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const switch_instance_changes = (dirty[0] & /*pages*/ 16)
			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*page*/ ctx[29].props)])
			: {};

			if (switch_value !== (switch_value = /*page*/ ctx[29].component)) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, t.parentNode, t);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (switch_instance) destroy_component(switch_instance, detaching);
			if (detaching) detach(t);
		}
	};
}

// (193:2) {#each pages as page (page.id)}
function create_each_block(key_1, ctx) {
	let first;
	let routercontextprovider;
	let current;

	routercontextprovider = new RouterContextProvider({
			props: {
				route: /*page*/ ctx[29].props.f7route,
				router: /*page*/ ctx[29].props.f7router,
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		key: key_1,
		first: null,
		c() {
			first = empty();
			create_component(routercontextprovider.$$.fragment);
			this.first = first;
		},
		m(target, anchor) {
			insert(target, first, anchor);
			mount_component(routercontextprovider, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const routercontextprovider_changes = {};
			if (dirty[0] & /*pages*/ 16) routercontextprovider_changes.route = /*page*/ ctx[29].props.f7route;
			if (dirty[0] & /*pages*/ 16) routercontextprovider_changes.router = /*page*/ ctx[29].props.f7router;

			if (dirty[0] & /*$$scope, pages*/ 4112) {
				routercontextprovider_changes.$$scope = { dirty, ctx };
			}

			routercontextprovider.$set(routercontextprovider_changes);
		},
		i(local) {
			if (current) return;
			transition_in(routercontextprovider.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(routercontextprovider.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(first);
			destroy_component(routercontextprovider, detaching);
		}
	};
}

function create_fragment(ctx) {
	let div;
	let t;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let current;
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], get_default_slot_context);
	let each_value = /*pages*/ ctx[4];
	const get_key = ctx => /*page*/ ctx[29].id;

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			t = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div, "class", /*classes*/ ctx[5]);
			attr(div, "style", /*style*/ ctx[1]);
			attr(div, "id", /*id*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			append(div, t);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			/*div_binding*/ ctx[11](div);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[0] & /*$$scope, f7View*/ 4104)) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[12], dirty, get_default_slot_changes, get_default_slot_context);
				}
			}

			if (dirty[0] & /*pages*/ 16) {
				each_value = /*pages*/ ctx[4];
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block, null, get_each_context);
				check_outros();
			}

			if (!current || dirty[0] & /*classes*/ 32) {
				attr(div, "class", /*classes*/ ctx[5]);
			}

			if (!current || dirty[0] & /*style*/ 2) {
				attr(div, "style", /*style*/ ctx[1]);
			}

			if (!current || dirty[0] & /*id*/ 1) {
				attr(div, "id", /*id*/ ctx[0]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			transition_out(default_slot, local);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			/*div_binding*/ ctx[11](null);
		}
	};
}

function instance_1($$self, $$props, $$invalidate) {
	let classes;
	let { $$slots: slots = {}, $$scope } = $$props;
	let { id = undefined } = $$props;
	let { style = undefined } = $$props;
	let { init = true } = $$props;
	let { url = undefined } = $$props;
	let { class: className = undefined } = $$props;
	const emit = createEmitter(createEventDispatcher, $$props);
	const { main, tab, tabActive, browserHistoryInitialMatch = true } = $$props;
	let initialPage;
	let initialRoute;
	let el;
	let routerData;
	let f7View;

	function instance() {
		return f7View;
	}

	function onViewInit(view) {
		emit("viewInit", [view]);

		if (!init) {
			$$invalidate(3, f7View = view);
			routerData.instance = view;
		}
	}

	if (app.f7 && !f7View && init) {
		const routerId = getRouterId();

		f7View = app.f7.views.create(el, {
			routerId,
			init: false,
			...noUndefinedProps($$props),
			browserHistoryInitialMatch,
			on: { init: onViewInit }
		});

		routerData = { routerId, instance: f7View };
		app.f7routers.views.push(routerData);

		if (f7View && f7View.router && (url || main)) {
			const initialData = getRouterInitialComponent(f7View.router);
			initialPage = initialData.initialPage;
			initialRoute = initialData.initialRoute;

			if (initialRoute && initialRoute.route && initialRoute.route.masterRoute) {
				initialPage = undefined;
				initialRoute = undefined;
			}
		}
	}

	let pages = initialPage ? [initialPage] : [];

	function onResize(view, width) {
		emit("viewResize", [width]);
	}

	function onSwipeBackMove(data) {
		emit("swipeBackMove", [data]);
	}

	function onSwipeBackBeforeChange(data) {
		emit("swipeBackBeforeChange", [data]);
	}

	function onSwipeBackAfterChange(data) {
		emit("swipeBackAfterChange", [data]);
	}

	function onSwipeBackBeforeReset(data) {
		emit("swipeBackBeforeReset", [data]);
	}

	function onSwipeBackAfterReset(data) {
		emit("swipeBackAfterReset", [data]);
	}

	useTab(() => el, emit);

	onMount(() => {
		f7ready(() => {
			if (f7View) {
				routerData.el = el;
				routerData.pages = pages;

				routerData.setPages = newPages => {
					tick().then(() => {
						$$invalidate(4, pages = newPages);
					});
				};

				if (initialPage && initialPage.isAsync && !initialPage.initialComponent) {
					initialPage.component().then(() => {
						setTimeout(
							() => {
								f7View.init(el);

								if (initialPage) {
									initialPage.el = f7View.router.currentPageEl;

									if (initialRoute && initialRoute.route && initialRoute.route.keepAlive) {
										initialRoute.route.keepAliveData = { pageEl: initialPage.el };
									}
								}
							},
							100
						);
					});
				} else {
					f7View.init(el);

					if (initialPage) {
						initialPage.el = f7View.router.currentPageEl;

						if (initialRoute && initialRoute.route && initialRoute.route.keepAlive) {
							initialRoute.route.keepAliveData = { pageEl: initialPage.el };
						}
					}
				}
			} else {
				const routerId = getRouterId();

				routerData = {
					el,
					routerId,
					pages,
					instance: f7View,
					setPages(newPages) {
						tick().then(() => {
							$$invalidate(4, pages = newPages);
						});
					}
				};

				app.f7routers.views.push(routerData);

				routerData.instance = app.f7.views.create(el, {
					routerId,
					...noUndefinedProps($$props),
					browserHistoryInitialMatch,
					on: { init: onViewInit }
				});

				$$invalidate(3, f7View = routerData.instance);
			}

			if (!init) return;
			f7View.on("resize", onResize);
			f7View.on("swipebackMove", onSwipeBackMove);
			f7View.on("swipebackBeforeChange", onSwipeBackBeforeChange);
			f7View.on("swipebackAfterChange", onSwipeBackAfterChange);
			f7View.on("swipebackBeforeReset", onSwipeBackBeforeReset);
			f7View.on("swipebackAfterReset", onSwipeBackAfterReset);
		});
	});

	afterUpdate(() => {
		if (!routerData) return;
		app.f7events.emit("viewRouterDidUpdate", routerData);
	});

	onDestroy(() => {
		if (f7View) {
			f7View.off("resize", onResize);
			f7View.off("swipebackMove", onSwipeBackMove);
			f7View.off("swipebackBeforeChange", onSwipeBackBeforeChange);
			f7View.off("swipebackAfterChange", onSwipeBackAfterChange);
			f7View.off("swipebackBeforeReset", onSwipeBackBeforeReset);
			f7View.off("swipebackAfterReset", onSwipeBackAfterReset);
			if (f7View.destroy) f7View.destroy();
			$$invalidate(3, f7View = null);
		}

		app.f7routers.views.splice(app.f7routers.views.indexOf(routerData), 1);
		routerData = null;
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(2, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(28, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
		if ("style" in $$new_props) $$invalidate(1, style = $$new_props.style);
		if ("init" in $$new_props) $$invalidate(6, init = $$new_props.init);
		if ("url" in $$new_props) $$invalidate(7, url = $$new_props.url);
		if ("class" in $$new_props) $$invalidate(8, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(5, classes = classNames(
			className,
			"view",
			{
				"view-main": main,
				"tab-active": tabActive,
				tab
			},
			colorClasses($$props)
		));
	};

	$$props = exclude_internal_props($$props);

	return [
		id,
		style,
		el,
		f7View,
		pages,
		classes,
		init,
		url,
		className,
		instance,
		slots,
		div_binding,
		$$scope
	];
}

class View extends SvelteComponent {
	constructor(options) {
		super();

		init_1(
			this,
			options,
			instance_1,
			create_fragment,
			safe_not_equal,
			{
				id: 0,
				style: 1,
				init: 6,
				url: 7,
				class: 8,
				instance: 9
			},
			[-1, -1]
		);
	}

	get instance() {
		return this.$$.ctx[9];
	}
}

export default View;