/* area-chart.svelte generated by Svelte v3.38.2 */
import {
	SvelteComponent,
	append,
	assign,
	attr,
	binding_callbacks,
	compute_rest_props,
	create_slot,
	destroy_block,
	destroy_each,
	detach,
	element,
	empty,
	exclude_internal_props,
	get_spread_update,
	init,
	insert,
	listen,
	safe_not_equal,
	set_attributes,
	set_data,
	space,
	svg_element,
	text,
	transition_in,
	transition_out,
	update_keyed_each,
	update_slot
} from "svelte/internal";

import { createEventDispatcher, onDestroy, onMount } from "svelte";
import { classNames, createEmitter } from "../shared/utils";
import { restProps } from "../shared/rest-props";
import { app } from "../shared/f7";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[54] = list[i];
	child_ctx[56] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[57] = list[i];
	child_ctx[56] = i;
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[59] = list[i];
	child_ctx[56] = i;
	return child_ctx;
}

function get_each_context_3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[61] = list[i];
	child_ctx[56] = i;
	return child_ctx;
}

// (305:6) {:else}
function create_else_block_1(ctx) {
	let polygon;
	let polygon_fill_value;
	let polygon_points_value;

	return {
		c() {
			polygon = svg_element("polygon");
			attr(polygon, "fill", polygon_fill_value = /*data*/ ctx[61].color);
			attr(polygon, "fillrule", "evenodd");
			attr(polygon, "points", polygon_points_value = /*data*/ ctx[61].points);
		},
		m(target, anchor) {
			insert(target, polygon, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*chartData*/ 8192 && polygon_fill_value !== (polygon_fill_value = /*data*/ ctx[61].color)) {
				attr(polygon, "fill", polygon_fill_value);
			}

			if (dirty[0] & /*chartData*/ 8192 && polygon_points_value !== (polygon_points_value = /*data*/ ctx[61].points)) {
				attr(polygon, "points", polygon_points_value);
			}
		},
		d(detaching) {
			if (detaching) detach(polygon);
		}
	};
}

// (303:6) {#if lineChart}
function create_if_block_4(ctx) {
	let path;
	let path_stroke_value;
	let path_d_value;

	return {
		c() {
			path = svg_element("path");
			attr(path, "stroke", path_stroke_value = /*data*/ ctx[61].color);
			attr(path, "fillrule", "evenodd");
			attr(path, "d", path_d_value = /*data*/ ctx[61].points);
		},
		m(target, anchor) {
			insert(target, path, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*chartData*/ 8192 && path_stroke_value !== (path_stroke_value = /*data*/ ctx[61].color)) {
				attr(path, "stroke", path_stroke_value);
			}

			if (dirty[0] & /*chartData*/ 8192 && path_d_value !== (path_d_value = /*data*/ ctx[61].points)) {
				attr(path, "d", path_d_value);
			}
		},
		d(detaching) {
			if (detaching) detach(path);
		}
	};
}

// (302:4) {#each chartData as data, index (index)}
function create_each_block_3(key_1, ctx) {
	let first;
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*lineChart*/ ctx[0]) return create_if_block_4;
		return create_else_block_1;
	}

	let current_block_type = select_block_type(ctx, [-1]);
	let if_block = current_block_type(ctx);

	return {
		key: key_1,
		first: null,
		c() {
			first = empty();
			if_block.c();
			if_block_anchor = empty();
			this.first = first;
		},
		m(target, anchor) {
			insert(target, first, anchor);
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if (detaching) detach(first);
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (310:4) {#each verticalLines as line, index (index)}
function create_each_block_2(key_1, ctx) {
	let line;
	let line_data_index_value;
	let line_x__value;
	let line_y__value;
	let line_x__value_1;
	let line_class_value;

	return {
		key: key_1,
		first: null,
		c() {
			line = svg_element("line");
			attr(line, "data-index", line_data_index_value = /*index*/ ctx[56]);
			attr(line, "fill", "#000");
			attr(line, "x1", line_x__value = /*line*/ ctx[59]);
			attr(line, "y1", line_y__value = 0);
			attr(line, "x2", line_x__value_1 = /*line*/ ctx[59]);
			attr(line, "y2", /*height*/ ctx[7]);

			attr(line, "class", line_class_value = classNames({
				"area-chart-current-line": /*currentIndex*/ ctx[8] === /*index*/ ctx[56]
			}));

			this.first = line;
		},
		m(target, anchor) {
			insert(target, line, anchor);
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*verticalLines*/ 16384 && line_data_index_value !== (line_data_index_value = /*index*/ ctx[56])) {
				attr(line, "data-index", line_data_index_value);
			}

			if (dirty[0] & /*verticalLines*/ 16384 && line_x__value !== (line_x__value = /*line*/ ctx[59])) {
				attr(line, "x1", line_x__value);
			}

			if (dirty[0] & /*verticalLines*/ 16384 && line_x__value_1 !== (line_x__value_1 = /*line*/ ctx[59])) {
				attr(line, "x2", line_x__value_1);
			}

			if (dirty[0] & /*height*/ 128) {
				attr(line, "y2", /*height*/ ctx[7]);
			}

			if (dirty[0] & /*currentIndex, verticalLines*/ 16640 && line_class_value !== (line_class_value = classNames({
				"area-chart-current-line": /*currentIndex*/ ctx[8] === /*index*/ ctx[56]
			}))) {
				attr(line, "class", line_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(line);
		}
	};
}

// (322:2) {#if axis}
function create_if_block_2(ctx) {
	let div;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let each_value_1 = /*axisLabels*/ ctx[3];
	const get_key = ctx => /*index*/ ctx[56];

	for (let i = 0; i < each_value_1.length; i += 1) {
		let child_ctx = get_each_context_1(ctx, each_value_1, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block_1(key, child_ctx));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div, "class", "area-chart-axis");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*formatAxisLabel, axisLabels, visibleLegends*/ 163848) {
				each_value_1 = /*axisLabels*/ ctx[3];
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, div, destroy_block, create_each_block_1, null, get_each_context_1);
			}
		},
		d(detaching) {
			if (detaching) detach(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}
		}
	};
}

// (326:10) {#if visibleLegends.includes(label)}
function create_if_block_3(ctx) {
	let span;
	let t_value = /*formatAxisLabel*/ ctx[17](/*label*/ ctx[57]) + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*axisLabels*/ 8 && t_value !== (t_value = /*formatAxisLabel*/ ctx[17](/*label*/ ctx[57]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (324:6) {#each axisLabels as label, index (index)}
function create_each_block_1(key_1, ctx) {
	let span;
	let show_if = /*visibleLegends*/ ctx[15].includes(/*label*/ ctx[57]);
	let t;
	let if_block = show_if && create_if_block_3(ctx);

	return {
		key: key_1,
		first: null,
		c() {
			span = element("span");
			if (if_block) if_block.c();
			t = space();
			this.first = span;
		},
		m(target, anchor) {
			insert(target, span, anchor);
			if (if_block) if_block.m(span, null);
			append(span, t);
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty[0] & /*visibleLegends, axisLabels*/ 32776) show_if = /*visibleLegends*/ ctx[15].includes(/*label*/ ctx[57]);

			if (show_if) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_3(ctx);
					if_block.c();
					if_block.m(span, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) detach(span);
			if (if_block) if_block.d();
		}
	};
}

// (331:2) {#if legend}
function create_if_block(ctx) {
	let div;
	let each_value = /*datasets*/ ctx[1];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div, "class", "area-chart-legend");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*hiddenDatasets, toggleDatasets, toggleDataset, formatLegendLabel, datasets*/ 328226) {
				each_value = /*datasets*/ ctx[1];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

// (346:8) {:else}
function create_else_block(ctx) {
	let span1;
	let span0;
	let span0_style_value;
	let t0;
	let t1_value = /*formatLegendLabel*/ ctx[18](/*dataset*/ ctx[54].label) + "";
	let t1;
	let t2;

	return {
		c() {
			span1 = element("span");
			span0 = element("span");
			t0 = space();
			t1 = text(t1_value);
			t2 = space();
			attr(span0, "style", span0_style_value = `background-color: ${/*dataset*/ ctx[54].color}`);
			attr(span1, "class", "area-chart-legend-item");
		},
		m(target, anchor) {
			insert(target, span1, anchor);
			append(span1, span0);
			append(span1, t0);
			append(span1, t1);
			append(span1, t2);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*datasets*/ 2 && span0_style_value !== (span0_style_value = `background-color: ${/*dataset*/ ctx[54].color}`)) {
				attr(span0, "style", span0_style_value);
			}

			if (dirty[0] & /*datasets*/ 2 && t1_value !== (t1_value = /*formatLegendLabel*/ ctx[18](/*dataset*/ ctx[54].label) + "")) set_data(t1, t1_value);
		},
		d(detaching) {
			if (detaching) detach(span1);
		}
	};
}

// (334:8) {#if toggleDatasets}
function create_if_block_1(ctx) {
	let button;
	let span;
	let span_style_value;
	let t0;
	let t1_value = /*formatLegendLabel*/ ctx[18](/*dataset*/ ctx[54].label) + "";
	let t1;
	let t2;
	let button_class_value;
	let mounted;
	let dispose;

	function click_handler() {
		return /*click_handler*/ ctx[32](/*index*/ ctx[56]);
	}

	return {
		c() {
			button = element("button");
			span = element("span");
			t0 = space();
			t1 = text(t1_value);
			t2 = space();
			attr(span, "style", span_style_value = `background-color: ${/*dataset*/ ctx[54].color}`);

			attr(button, "class", button_class_value = classNames("area-chart-legend-item", {
				"area-chart-legend-item-hidden": /*hiddenDatasets*/ ctx[9].includes(/*index*/ ctx[56]),
				"area-chart-legend-button": /*toggleDatasets*/ ctx[5]
			}));

			attr(button, "type", "button");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, span);
			append(button, t0);
			append(button, t1);
			append(button, t2);

			if (!mounted) {
				dispose = listen(button, "click", click_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*datasets*/ 2 && span_style_value !== (span_style_value = `background-color: ${/*dataset*/ ctx[54].color}`)) {
				attr(span, "style", span_style_value);
			}

			if (dirty[0] & /*datasets*/ 2 && t1_value !== (t1_value = /*formatLegendLabel*/ ctx[18](/*dataset*/ ctx[54].label) + "")) set_data(t1, t1_value);

			if (dirty[0] & /*hiddenDatasets, toggleDatasets*/ 544 && button_class_value !== (button_class_value = classNames("area-chart-legend-item", {
				"area-chart-legend-item-hidden": /*hiddenDatasets*/ ctx[9].includes(/*index*/ ctx[56]),
				"area-chart-legend-button": /*toggleDatasets*/ ctx[5]
			}))) {
				attr(button, "class", button_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			dispose();
		}
	};
}

// (333:6) {#each datasets as dataset, index}
function create_each_block(ctx) {
	let if_block_anchor;

	function select_block_type_1(ctx, dirty) {
		if (/*toggleDatasets*/ ctx[5]) return create_if_block_1;
		return create_else_block;
	}

	let current_block_type = select_block_type_1(ctx, [-1]);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment(ctx) {
	let div;
	let svg;
	let each_blocks_1 = [];
	let each0_lookup = new Map();
	let each0_anchor;
	let each_blocks = [];
	let each1_lookup = new Map();
	let svg_viewBox_value;
	let t0;
	let t1;
	let t2;
	let current;
	let each_value_3 = /*chartData*/ ctx[13];
	const get_key = ctx => /*index*/ ctx[56];

	for (let i = 0; i < each_value_3.length; i += 1) {
		let child_ctx = get_each_context_3(ctx, each_value_3, i);
		let key = get_key(child_ctx);
		each0_lookup.set(key, each_blocks_1[i] = create_each_block_3(key, child_ctx));
	}

	let each_value_2 = /*verticalLines*/ ctx[14];
	const get_key_1 = ctx => /*index*/ ctx[56];

	for (let i = 0; i < each_value_2.length; i += 1) {
		let child_ctx = get_each_context_2(ctx, each_value_2, i);
		let key = get_key_1(child_ctx);
		each1_lookup.set(key, each_blocks[i] = create_each_block_2(key, child_ctx));
	}

	let if_block0 = /*axis*/ ctx[2] && create_if_block_2(ctx);
	let if_block1 = /*legend*/ ctx[4] && create_if_block(ctx);
	const default_slot_template = /*#slots*/ ctx[30].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[29], null);
	let div_levels = [{ class: /*classes*/ ctx[12] }, restProps(/*$$restProps*/ ctx[19])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			svg = svg_element("svg");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			each0_anchor = empty();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (default_slot) default_slot.c();
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", /*width*/ ctx[6]);
			attr(svg, "height", /*height*/ ctx[7]);
			attr(svg, "viewBox", svg_viewBox_value = `0 0 ${/*width*/ ctx[6]} ${/*height*/ ctx[7]}`);
			attr(svg, "preserveAspectRatio", "none");
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, svg);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(svg, null);
			}

			append(svg, each0_anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(svg, null);
			}

			/*svg_binding*/ ctx[31](svg);
			append(div, t0);
			if (if_block0) if_block0.m(div, null);
			append(div, t1);
			if (if_block1) if_block1.m(div, null);
			append(div, t2);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[33](div);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*chartData, lineChart*/ 8193) {
				each_value_3 = /*chartData*/ ctx[13];
				each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key, 1, ctx, each_value_3, each0_lookup, svg, destroy_block, create_each_block_3, each0_anchor, get_each_context_3);
			}

			if (dirty[0] & /*verticalLines, height, currentIndex*/ 16768) {
				each_value_2 = /*verticalLines*/ ctx[14];
				each_blocks = update_keyed_each(each_blocks, dirty, get_key_1, 1, ctx, each_value_2, each1_lookup, svg, destroy_block, create_each_block_2, null, get_each_context_2);
			}

			if (!current || dirty[0] & /*width*/ 64) {
				attr(svg, "width", /*width*/ ctx[6]);
			}

			if (!current || dirty[0] & /*height*/ 128) {
				attr(svg, "height", /*height*/ ctx[7]);
			}

			if (!current || dirty[0] & /*width, height*/ 192 && svg_viewBox_value !== (svg_viewBox_value = `0 0 ${/*width*/ ctx[6]} ${/*height*/ ctx[7]}`)) {
				attr(svg, "viewBox", svg_viewBox_value);
			}

			if (/*axis*/ ctx[2]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_2(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*legend*/ ctx[4]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[0] & /*$$scope*/ 536870912)) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[29], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty[0] & /*classes*/ 4096) && { class: /*classes*/ ctx[12] },
				dirty[0] & /*$$restProps*/ 524288 && restProps(/*$$restProps*/ ctx[19])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].d();
			}

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			/*svg_binding*/ ctx[31](null);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[33](null);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let classes;
	let chartData;
	let verticalLines;
	let visibleLegends;

	const omit_props_names = [
		"class","lineChart","datasets","axis","axisLabels","tooltip","legend","toggleDatasets","width","height","maxAxisLabels","formatAxisLabel","formatLegendLabel","formatTooltip","formatTooltipAxisLabel","formatTooltipTotal","formatTooltipDataset"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { lineChart = false } = $$props;
	let { datasets = [] } = $$props;
	let { axis = false } = $$props;
	let { axisLabels = [] } = $$props;
	let { tooltip = false } = $$props;
	let { legend = false } = $$props;
	let { toggleDatasets = false } = $$props;
	let { width = 640 } = $$props;
	let { height = 320 } = $$props;
	let { maxAxisLabels = 8 } = $$props;
	let { formatAxisLabel: formatAxisLabelProp = undefined } = $$props;
	let { formatLegendLabel: formatLegendLabelProp = undefined } = $$props;
	let { formatTooltip: formatTooltipProp = undefined } = $$props;
	let { formatTooltipAxisLabel = undefined } = $$props;
	let { formatTooltipTotal = undefined } = $$props;
	let { formatTooltipDataset = undefined } = $$props;
	let el;
	let svgEl = null;
	let currentIndex = null;
	let previousIndex = null;
	let hiddenDatasets = [];
	let f7Tooltip = null;
	let linesOffsets = null;

	const setCurrentIndex = value => {
		previousIndex = currentIndex;
		$$invalidate(8, currentIndex = value);
	};

	const setHiddenDatasets = value => {
		$$invalidate(9, hiddenDatasets = value);
	};

	const getVisibleLegends = () => {
		if (!maxAxisLabels || axisLabels.length <= maxAxisLabels) return axisLabels;
		const skipStep = Math.ceil(axisLabels.length / maxAxisLabels);
		const filtered = axisLabels.filter((label, index) => index % skipStep === 0);
		return filtered;
	};

	const getSummValues = () => {
		const summValues = [];

		datasets.filter((dataset, index) => !hiddenDatasets.includes(index)).forEach(({ values }) => {
			values.forEach((value, valueIndex) => {
				if (!summValues[valueIndex]) summValues[valueIndex] = 0;
				summValues[valueIndex] += value;
			});
		});

		return summValues;
	};

	const getChartData = () => {
		const data = [];

		if (!datasets.length) {
			return data;
		}

		const lastValues = datasets[0].values.map(() => 0);
		let maxValue = 0;

		if (lineChart) {
			datasets.forEach(({ values }) => {
				const datasetMaxValue = Math.max(...values);
				if (datasetMaxValue > maxValue) maxValue = datasetMaxValue;
			});
		} else {
			maxValue = Math.max(...getSummValues());
		}

		datasets.filter((dataset, index) => !hiddenDatasets.includes(index)).forEach(({ label, values, color }) => {
			const points = values.map((originalValue, valueIndex) => {
				lastValues[valueIndex] += originalValue;
				const value = lineChart ? originalValue : lastValues[valueIndex];
				const x = valueIndex / (values.length - 1) * width;
				const y = height - value / maxValue * height;

				if (lineChart) {
					return `${valueIndex === 0 ? "M" : "L"}${x},${y}`;
				}

				return `${x} ${y}`;
			});

			if (!lineChart) {
				points.push(`${width} ${height} 0 ${height}`);
			}

			data.push({ label, points: points.join(" "), color });
		});

		return data.reverse();
	};

	const getVerticalLines = () => {
		const lines = [];

		if (!datasets.length) {
			return lines;
		}

		const values = datasets[0].values;

		values.forEach((value, valueIndex) => {
			const x = valueIndex / (values.length - 1) * width;
			lines.push(x);
		});

		return lines;
	};

	const toggleDataset = index => {
		if (!toggleDatasets) return;

		if (hiddenDatasets.includes(index)) {
			hiddenDatasets.splice(hiddenDatasets.indexOf(index), 1);
		} else {
			hiddenDatasets.push(index);
		}

		setHiddenDatasets([...hiddenDatasets]);
	};

	const formatAxisLabel = label => {
		if (formatAxisLabelProp) return formatAxisLabelProp(label);
		return label;
	};

	const formatLegendLabel = label => {
		if (formatLegendLabelProp) return formatLegendLabelProp(label);
		return label;
	};

	const calcLinesOffsets = () => {
		const lines = svgEl.querySelectorAll("line");
		linesOffsets = [];

		for (let i = 0; i < lines.length; i += 1) {
			linesOffsets.push(lines[i].getBoundingClientRect().left);
		}
	};

	const formatTooltip = () => {
		if (currentIndex === null) return "";
		let total = 0;

		const currentValues = datasets.filter((dataset, index) => !hiddenDatasets.includes(index)).map(dataset => ({
			color: dataset.color,
			label: dataset.label,
			value: dataset.values[currentIndex]
		}));

		currentValues.forEach(dataset => {
			total += dataset.value;
		});

		if (formatTooltipProp) {
			return formatTooltipProp({
				index: currentIndex,
				total,
				datasets: currentValues
			});
		}

		let labelText = formatTooltipAxisLabel
		? formatTooltipAxisLabel(axisLabels[currentIndex])
		: formatAxisLabel(axisLabels[currentIndex]);

		if (!labelText) labelText = "";
		const totalText = formatTooltipTotal ? formatTooltipTotal(total) : total;

		// prettier-ignore
		const datasetsText = currentValues.length > 0
		? `
      <ul class="area-chart-tooltip-list">
        ${currentValues.map(({ label, color, value }) => {
				const valueText = formatTooltipDataset
				? formatTooltipDataset(label, value, color)
				: `${label}: ${value}`;

				return `
              <li><span style="background-color: ${color};"></span>${valueText}</li>
            `;
			}).join("")}
      </ul>`
		: "";

		// prettier-ignore
		return `
      <div class="area-chart-tooltip-label">${labelText}</div>
      <div class="area-chart-tooltip-total">${totalText}</div>
      ${datasetsText}
    `;
	};

	const setTooltip = () => {
		if (!tooltip) return;
		if (currentIndex === null && !f7Tooltip) return;
		const hasVisibleDataSets = datasets.filter((dataset, index) => !hiddenDatasets.includes(index)).length > 0;

		if (!hasVisibleDataSets) {
			if (f7Tooltip && f7Tooltip.hide) f7Tooltip.hide();
			return;
		}

		if (currentIndex !== null && !f7Tooltip) {
			f7Tooltip = app.f7.tooltip.create({
				trigger: "manual",
				containerEl: el,
				targetEl: svgEl.querySelector(`line[data-index="${currentIndex}"]`),
				text: formatTooltip(),
				cssClass: "area-chart-tooltip"
			});

			if (f7Tooltip && f7Tooltip.show) {
				f7Tooltip.show();
			}

			return;
		}

		if (!f7Tooltip || !f7Tooltip.hide || !f7Tooltip.show) {
			return;
		}

		if (currentIndex !== null) {
			f7Tooltip.setText(formatTooltip());
			f7Tooltip.setTargetEl(svgEl.querySelector(`line[data-index="${currentIndex}"]`));
			f7Tooltip.show();
		} else {
			f7Tooltip.hide();
		}
	};

	const onMouseEnter = () => {
		calcLinesOffsets();
	};

	const onMouseMove = e => {
		if (!linesOffsets) {
			calcLinesOffsets();
		}

		let currentLeft = e.pageX;
		if (typeof currentLeft === "undefined") currentLeft = 0;
		const distances = linesOffsets.map(left => Math.abs(currentLeft - left));
		const minDistance = Math.min(...distances);
		const closestIndex = distances.indexOf(minDistance);
		setCurrentIndex(closestIndex);
	};

	const onMouseLeave = () => {
		setCurrentIndex(null);
	};

	const attachEvents = () => {
		if (!svgEl) return;
		svgEl.addEventListener("mouseenter", onMouseEnter);
		svgEl.addEventListener("mousemove", onMouseMove);
		svgEl.addEventListener("mouseleave", onMouseLeave);
	};

	const detachEvents = () => {
		if (!svgEl) return;
		svgEl.removeEventListener("mouseenter", onMouseEnter);
		svgEl.removeEventListener("mousemove", onMouseMove);
		svgEl.removeEventListener("mouseleave", onMouseLeave);
	};

	onMount(() => {
		attachEvents();
	});

	onDestroy(() => {
		detachEvents();

		if (f7Tooltip && f7Tooltip.destroy) {
			f7Tooltip.destroy();
		}

		f7Tooltip = null;
	});

	const watchCurrentIndex = () => {
		if (currentIndex === previousIndex) return;
		emit("select", [currentIndex]);
		setTooltip();
	};

	function svg_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			svgEl = $$value;
			$$invalidate(11, svgEl);
		});
	}

	const click_handler = index => toggleDataset(index);

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(10, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(53, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(19, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(20, className = $$new_props.class);
		if ("lineChart" in $$new_props) $$invalidate(0, lineChart = $$new_props.lineChart);
		if ("datasets" in $$new_props) $$invalidate(1, datasets = $$new_props.datasets);
		if ("axis" in $$new_props) $$invalidate(2, axis = $$new_props.axis);
		if ("axisLabels" in $$new_props) $$invalidate(3, axisLabels = $$new_props.axisLabels);
		if ("tooltip" in $$new_props) $$invalidate(21, tooltip = $$new_props.tooltip);
		if ("legend" in $$new_props) $$invalidate(4, legend = $$new_props.legend);
		if ("toggleDatasets" in $$new_props) $$invalidate(5, toggleDatasets = $$new_props.toggleDatasets);
		if ("width" in $$new_props) $$invalidate(6, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(7, height = $$new_props.height);
		if ("maxAxisLabels" in $$new_props) $$invalidate(22, maxAxisLabels = $$new_props.maxAxisLabels);
		if ("formatAxisLabel" in $$new_props) $$invalidate(23, formatAxisLabelProp = $$new_props.formatAxisLabel);
		if ("formatLegendLabel" in $$new_props) $$invalidate(24, formatLegendLabelProp = $$new_props.formatLegendLabel);
		if ("formatTooltip" in $$new_props) $$invalidate(25, formatTooltipProp = $$new_props.formatTooltip);
		if ("formatTooltipAxisLabel" in $$new_props) $$invalidate(26, formatTooltipAxisLabel = $$new_props.formatTooltipAxisLabel);
		if ("formatTooltipTotal" in $$new_props) $$invalidate(27, formatTooltipTotal = $$new_props.formatTooltipTotal);
		if ("formatTooltipDataset" in $$new_props) $$invalidate(28, formatTooltipDataset = $$new_props.formatTooltipDataset);
		if ("$$scope" in $$new_props) $$invalidate(29, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*currentIndex*/ 256) {
			$: watchCurrentIndex(currentIndex);
		}

		if ($$self.$$.dirty[0] & /*className*/ 1048576) {
			$: $$invalidate(12, classes = classNames("area-chart", className));
		}

		if ($$self.$$.dirty[0] & /*datasets, hiddenDatasets*/ 514) {
			$: $$invalidate(13, chartData = getChartData(datasets, hiddenDatasets));
		}

		if ($$self.$$.dirty[0] & /*datasets*/ 2) {
			$: $$invalidate(14, verticalLines = getVerticalLines(datasets));
		}

		if ($$self.$$.dirty[0] & /*maxAxisLabels, axisLabels*/ 4194312) {
			$: $$invalidate(15, visibleLegends = getVisibleLegends(maxAxisLabels, axisLabels));
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		lineChart,
		datasets,
		axis,
		axisLabels,
		legend,
		toggleDatasets,
		width,
		height,
		currentIndex,
		hiddenDatasets,
		el,
		svgEl,
		classes,
		chartData,
		verticalLines,
		visibleLegends,
		toggleDataset,
		formatAxisLabel,
		formatLegendLabel,
		$$restProps,
		className,
		tooltip,
		maxAxisLabels,
		formatAxisLabelProp,
		formatLegendLabelProp,
		formatTooltipProp,
		formatTooltipAxisLabel,
		formatTooltipTotal,
		formatTooltipDataset,
		$$scope,
		slots,
		svg_binding,
		click_handler,
		div_binding
	];
}

class Area_chart extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				class: 20,
				lineChart: 0,
				datasets: 1,
				axis: 2,
				axisLabels: 3,
				tooltip: 21,
				legend: 4,
				toggleDatasets: 5,
				width: 6,
				height: 7,
				maxAxisLabels: 22,
				formatAxisLabel: 23,
				formatLegendLabel: 24,
				formatTooltip: 25,
				formatTooltipAxisLabel: 26,
				formatTooltipTotal: 27,
				formatTooltipDataset: 28
			},
			[-1, -1, -1]
		);
	}
}

export default Area_chart;