/* card.svelte generated by Svelte v3.38.2 */
import {
	SvelteComponent,
	append,
	assign,
	binding_callbacks,
	check_outros,
	compute_rest_props,
	compute_slots,
	create_component,
	create_slot,
	destroy_component,
	detach,
	element,
	exclude_internal_props,
	get_spread_update,
	group_outros,
	init,
	insert,
	mount_component,
	safe_not_equal,
	set_attributes,
	set_data,
	space,
	text,
	transition_in,
	transition_out,
	update_slot
} from "svelte/internal";

import { createEventDispatcher, onMount, onDestroy } from "svelte";
import { colorClasses } from "../shared/mixins";
import { classNames, plainText, createEmitter } from "../shared/utils";
import { restProps } from "../shared/rest-props";
import { app, f7ready } from "../shared/f7";
import CardHeader from "./card-header";
import CardContent from "./card-content";
import CardFooter from "./card-footer";
const get_footer_slot_changes = dirty => ({});
const get_footer_slot_context = ctx => ({});
const get_content_slot_changes = dirty => ({});
const get_content_slot_context = ctx => ({});
const get_header_slot_changes = dirty => ({});
const get_header_slot_context = ctx => ({});

// (151:2) {#if typeof title !== 'undefined' || hasHeaderSlots}
function create_if_block_2(ctx) {
	let cardheader;
	let current;

	cardheader = new CardHeader({
			props: {
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(cardheader.$$.fragment);
		},
		m(target, anchor) {
			mount_component(cardheader, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const cardheader_changes = {};

			if (dirty[0] & /*$$scope, title*/ 268435457) {
				cardheader_changes.$$scope = { dirty, ctx };
			}

			cardheader.$set(cardheader_changes);
		},
		i(local) {
			if (current) return;
			transition_in(cardheader.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(cardheader.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(cardheader, detaching);
		}
	};
}

// (152:4) <CardHeader>
function create_default_slot_2(ctx) {
	let t0_value = plainText(/*title*/ ctx[0]) + "";
	let t0;
	let t1;
	let current;
	const header_slot_template = /*#slots*/ ctx[26].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[28], get_header_slot_context);

	return {
		c() {
			t0 = text(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);

			if (header_slot) {
				header_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*title*/ 1) && t0_value !== (t0_value = plainText(/*title*/ ctx[0]) + "")) set_data(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && (!current || dirty[0] & /*$$scope*/ 268435456)) {
					update_slot(header_slot, header_slot_template, ctx, /*$$scope*/ ctx[28], dirty, get_header_slot_changes, get_header_slot_context);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
			if (header_slot) header_slot.d(detaching);
		}
	};
}

// (157:2) {#if typeof content !== 'undefined' || hasContentSlots}
function create_if_block_1(ctx) {
	let cardcontent;
	let current;

	cardcontent = new CardContent({
			props: {
				padding: /*padding*/ ctx[12],
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(cardcontent.$$.fragment);
		},
		m(target, anchor) {
			mount_component(cardcontent, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const cardcontent_changes = {};
			if (dirty[0] & /*padding*/ 4096) cardcontent_changes.padding = /*padding*/ ctx[12];

			if (dirty[0] & /*$$scope, content*/ 268435458) {
				cardcontent_changes.$$scope = { dirty, ctx };
			}

			cardcontent.$set(cardcontent_changes);
		},
		i(local) {
			if (current) return;
			transition_in(cardcontent.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(cardcontent.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(cardcontent, detaching);
		}
	};
}

// (158:4) <CardContent {padding}>
function create_default_slot_1(ctx) {
	let t0_value = plainText(/*content*/ ctx[1]) + "";
	let t0;
	let t1;
	let current;
	const content_slot_template = /*#slots*/ ctx[26].content;
	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[28], get_content_slot_context);

	return {
		c() {
			t0 = text(t0_value);
			t1 = space();
			if (content_slot) content_slot.c();
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);

			if (content_slot) {
				content_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*content*/ 2) && t0_value !== (t0_value = plainText(/*content*/ ctx[1]) + "")) set_data(t0, t0_value);

			if (content_slot) {
				if (content_slot.p && (!current || dirty[0] & /*$$scope*/ 268435456)) {
					update_slot(content_slot, content_slot_template, ctx, /*$$scope*/ ctx[28], dirty, get_content_slot_changes, get_content_slot_context);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(content_slot, local);
			current = true;
		},
		o(local) {
			transition_out(content_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
			if (content_slot) content_slot.d(detaching);
		}
	};
}

// (163:2) {#if typeof footer !== 'undefined' || hasFooterSlots}
function create_if_block(ctx) {
	let cardfooter;
	let current;

	cardfooter = new CardFooter({
			props: {
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(cardfooter.$$.fragment);
		},
		m(target, anchor) {
			mount_component(cardfooter, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const cardfooter_changes = {};

			if (dirty[0] & /*$$scope, footer*/ 268435460) {
				cardfooter_changes.$$scope = { dirty, ctx };
			}

			cardfooter.$set(cardfooter_changes);
		},
		i(local) {
			if (current) return;
			transition_in(cardfooter.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(cardfooter.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(cardfooter, detaching);
		}
	};
}

// (164:4) <CardFooter>
function create_default_slot(ctx) {
	let t0_value = plainText(/*footer*/ ctx[2]) + "";
	let t0;
	let t1;
	let current;
	const footer_slot_template = /*#slots*/ ctx[26].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[28], get_footer_slot_context);

	return {
		c() {
			t0 = text(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);

			if (footer_slot) {
				footer_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 4) && t0_value !== (t0_value = plainText(/*footer*/ ctx[2]) + "")) set_data(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && (!current || dirty[0] & /*$$scope*/ 268435456)) {
					update_slot(footer_slot, footer_slot_template, ctx, /*$$scope*/ ctx[28], dirty, get_footer_slot_changes, get_footer_slot_context);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
			if (footer_slot) footer_slot.d(detaching);
		}
	};
}

function create_fragment(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let div_data_animate_value;
	let div_data_hide_navbar_on_open_value;
	let div_data_hide_toolbar_on_open_value;
	let div_data_hide_statusbar_on_open_value;
	let div_data_swipe_to_close_value;
	let div_data_close_by_backdrop_click_value;
	let div_data_backdrop_value;
	let current;
	let if_block0 = (typeof /*title*/ ctx[0] !== "undefined" || /*hasHeaderSlots*/ ctx[15]) && create_if_block_2(ctx);
	let if_block1 = (typeof /*content*/ ctx[1] !== "undefined" || /*hasContentSlots*/ ctx[16]) && create_if_block_1(ctx);
	let if_block2 = (typeof /*footer*/ ctx[2] !== "undefined" || /*hasFooterSlots*/ ctx[17]) && create_if_block(ctx);
	const default_slot_template = /*#slots*/ ctx[26].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[28], null);

	let div_levels = [
		{ class: /*classes*/ ctx[14] },
		{
			"data-animate": div_data_animate_value = typeof /*animate*/ ctx[3] === "undefined"
			? /*animate*/ ctx[3]
			: /*animate*/ ctx[3].toString()
		},
		{
			"data-hide-navbar-on-open": div_data_hide_navbar_on_open_value = typeof /*hideNavbarOnOpen*/ ctx[4] === "undefined"
			? /*hideNavbarOnOpen*/ ctx[4]
			: /*hideNavbarOnOpen*/ ctx[4].toString()
		},
		{
			"data-hide-toolbar-on-open": div_data_hide_toolbar_on_open_value = typeof /*hideToolbarOnOpen*/ ctx[5] === "undefined"
			? /*hideToolbarOnOpen*/ ctx[5]
			: /*hideToolbarOnOpen*/ ctx[5].toString()
		},
		{
			"data-hide-statusbar-on-open": div_data_hide_statusbar_on_open_value = typeof /*hideStatusbarOnOpen*/ ctx[6] === "undefined"
			? /*hideStatusbarOnOpen*/ ctx[6]
			: /*hideStatusbarOnOpen*/ ctx[6].toString()
		},
		{
			"data-scrollable-el": /*scrollableEl*/ ctx[7]
		},
		{
			"data-swipe-to-close": div_data_swipe_to_close_value = typeof /*swipeToClose*/ ctx[8] === "undefined"
			? /*swipeToClose*/ ctx[8]
			: /*swipeToClose*/ ctx[8].toString()
		},
		{
			"data-close-by-backdrop-click": div_data_close_by_backdrop_click_value = typeof /*closeByBackdropClick*/ ctx[9] === "undefined"
			? /*closeByBackdropClick*/ ctx[9]
			: /*closeByBackdropClick*/ ctx[9].toString()
		},
		{
			"data-backdrop": div_data_backdrop_value = typeof /*backdrop*/ ctx[10] === "undefined"
			? /*backdrop*/ ctx[10]
			: /*backdrop*/ ctx[10].toString()
		},
		{
			"data-backdrop-el": /*backdropEl*/ ctx[11]
		},
		restProps(/*$$restProps*/ ctx[18])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			t2 = space();
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append(div, t0);
			if (if_block1) if_block1.m(div, null);
			append(div, t1);
			if (if_block2) if_block2.m(div, null);
			append(div, t2);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[27](div);
			current = true;
		},
		p(ctx, dirty) {
			if (typeof /*title*/ ctx[0] !== "undefined" || /*hasHeaderSlots*/ ctx[15]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*title, hasHeaderSlots*/ 32769) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (typeof /*content*/ ctx[1] !== "undefined" || /*hasContentSlots*/ ctx[16]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*content, hasContentSlots*/ 65538) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (typeof /*footer*/ ctx[2] !== "undefined" || /*hasFooterSlots*/ ctx[17]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*footer, hasFooterSlots*/ 131076) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div, t2);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[0] & /*$$scope*/ 268435456)) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[28], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty[0] & /*classes*/ 16384) && { class: /*classes*/ ctx[14] },
				(!current || dirty[0] & /*animate*/ 8 && div_data_animate_value !== (div_data_animate_value = typeof /*animate*/ ctx[3] === "undefined"
				? /*animate*/ ctx[3]
				: /*animate*/ ctx[3].toString())) && { "data-animate": div_data_animate_value },
				(!current || dirty[0] & /*hideNavbarOnOpen*/ 16 && div_data_hide_navbar_on_open_value !== (div_data_hide_navbar_on_open_value = typeof /*hideNavbarOnOpen*/ ctx[4] === "undefined"
				? /*hideNavbarOnOpen*/ ctx[4]
				: /*hideNavbarOnOpen*/ ctx[4].toString())) && {
					"data-hide-navbar-on-open": div_data_hide_navbar_on_open_value
				},
				(!current || dirty[0] & /*hideToolbarOnOpen*/ 32 && div_data_hide_toolbar_on_open_value !== (div_data_hide_toolbar_on_open_value = typeof /*hideToolbarOnOpen*/ ctx[5] === "undefined"
				? /*hideToolbarOnOpen*/ ctx[5]
				: /*hideToolbarOnOpen*/ ctx[5].toString())) && {
					"data-hide-toolbar-on-open": div_data_hide_toolbar_on_open_value
				},
				(!current || dirty[0] & /*hideStatusbarOnOpen*/ 64 && div_data_hide_statusbar_on_open_value !== (div_data_hide_statusbar_on_open_value = typeof /*hideStatusbarOnOpen*/ ctx[6] === "undefined"
				? /*hideStatusbarOnOpen*/ ctx[6]
				: /*hideStatusbarOnOpen*/ ctx[6].toString())) && {
					"data-hide-statusbar-on-open": div_data_hide_statusbar_on_open_value
				},
				(!current || dirty[0] & /*scrollableEl*/ 128) && {
					"data-scrollable-el": /*scrollableEl*/ ctx[7]
				},
				(!current || dirty[0] & /*swipeToClose*/ 256 && div_data_swipe_to_close_value !== (div_data_swipe_to_close_value = typeof /*swipeToClose*/ ctx[8] === "undefined"
				? /*swipeToClose*/ ctx[8]
				: /*swipeToClose*/ ctx[8].toString())) && {
					"data-swipe-to-close": div_data_swipe_to_close_value
				},
				(!current || dirty[0] & /*closeByBackdropClick*/ 512 && div_data_close_by_backdrop_click_value !== (div_data_close_by_backdrop_click_value = typeof /*closeByBackdropClick*/ ctx[9] === "undefined"
				? /*closeByBackdropClick*/ ctx[9]
				: /*closeByBackdropClick*/ ctx[9].toString())) && {
					"data-close-by-backdrop-click": div_data_close_by_backdrop_click_value
				},
				(!current || dirty[0] & /*backdrop*/ 1024 && div_data_backdrop_value !== (div_data_backdrop_value = typeof /*backdrop*/ ctx[10] === "undefined"
				? /*backdrop*/ ctx[10]
				: /*backdrop*/ ctx[10].toString())) && { "data-backdrop": div_data_backdrop_value },
				(!current || dirty[0] & /*backdropEl*/ 2048) && {
					"data-backdrop-el": /*backdropEl*/ ctx[11]
				},
				dirty[0] & /*$$restProps*/ 262144 && restProps(/*$$restProps*/ ctx[18])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block2);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block2);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[27](null);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let classes;
	let hasHeaderSlots;
	let hasContentSlots;
	let hasFooterSlots;

	const omit_props_names = [
		"class","title","content","footer","outline","expandable","expandableAnimateWidth","expandableOpened","animate","hideNavbarOnOpen","hideToolbarOnOpen","hideStatusbarOnOpen","scrollableEl","swipeToClose","closeByBackdropClick","backdrop","backdropEl","noShadow","noBorder","padding"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = compute_slots(slots);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { title = undefined } = $$props;
	let { content = undefined } = $$props;
	let { footer = undefined } = $$props;
	let { outline = false } = $$props;
	let { expandable = false } = $$props;
	let { expandableAnimateWidth = false } = $$props;
	let { expandableOpened = false } = $$props;
	let { animate = undefined } = $$props;
	let { hideNavbarOnOpen = undefined } = $$props;
	let { hideToolbarOnOpen = undefined } = $$props;
	let { hideStatusbarOnOpen = undefined } = $$props;
	let { scrollableEl = undefined } = $$props;
	let { swipeToClose = undefined } = $$props;
	let { closeByBackdropClick = undefined } = $$props;
	let { backdrop = undefined } = $$props;
	let { backdropEl = undefined } = $$props;
	let { noShadow = false } = $$props;
	let { noBorder = false } = $$props;
	let { padding = true } = $$props;
	let el;

	/* eslint-enable no-undef */
	function open() {
		app.f7.card.open(el);
	}

	function close() {
		app.f7.card.close(el);
	}

	let initialWatched = false;

	function watchOpened(openedPassed) {
		if (!initialWatched) {
			initialWatched = true;
			return;
		}

		if (openedPassed) {
			open();
		} else {
			close();
		}
	}

	function onBeforeOpen(cardEl, prevent) {
		if (cardEl !== el) return;
		emit("cardBeforeOpen", [el, prevent]);
	}

	function onOpen(cardEl) {
		if (cardEl !== el) return;
		emit("cardOpen", [el]);
		$$invalidate(19, expandableOpened = true);
	}

	function onOpened(cardEl, pageEl) {
		if (cardEl !== el) return;
		emit("cardOpened", [el, pageEl]);
	}

	function onClose(cardEl) {
		if (cardEl !== el) return;
		emit("cardClose", [el]);
	}

	function onClosed(cardEl, pageEl) {
		if (cardEl !== el) return;
		emit("cardClosed", [el, pageEl]);
		$$invalidate(19, expandableOpened = false);
	}

	onMount(() => {
		if (!expandable) return;

		f7ready(() => {
			app.f7.on("cardBeforeOpen", onBeforeOpen);
			app.f7.on("cardOpen", onOpen);
			app.f7.on("cardOpened", onOpened);
			app.f7.on("cardClose", onClose);
			app.f7.on("cardClosed", onClosed);

			if (expandable && expandableOpened && el) {
				app.f7.card.open(el, false);
			}
		});
	});

	onDestroy(() => {
		if (!expandable) return;
		if (!app.f7 || !el) return;
		app.f7.off("cardBeforeOpen", onBeforeOpen);
		app.f7.off("cardOpen", onOpen);
		app.f7.off("cardOpened", onOpened);
		app.f7.off("cardClose", onClose);
		app.f7.off("cardClosed", onClosed);
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(13, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(39, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(18, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(20, className = $$new_props.class);
		if ("title" in $$new_props) $$invalidate(0, title = $$new_props.title);
		if ("content" in $$new_props) $$invalidate(1, content = $$new_props.content);
		if ("footer" in $$new_props) $$invalidate(2, footer = $$new_props.footer);
		if ("outline" in $$new_props) $$invalidate(21, outline = $$new_props.outline);
		if ("expandable" in $$new_props) $$invalidate(22, expandable = $$new_props.expandable);
		if ("expandableAnimateWidth" in $$new_props) $$invalidate(23, expandableAnimateWidth = $$new_props.expandableAnimateWidth);
		if ("expandableOpened" in $$new_props) $$invalidate(19, expandableOpened = $$new_props.expandableOpened);
		if ("animate" in $$new_props) $$invalidate(3, animate = $$new_props.animate);
		if ("hideNavbarOnOpen" in $$new_props) $$invalidate(4, hideNavbarOnOpen = $$new_props.hideNavbarOnOpen);
		if ("hideToolbarOnOpen" in $$new_props) $$invalidate(5, hideToolbarOnOpen = $$new_props.hideToolbarOnOpen);
		if ("hideStatusbarOnOpen" in $$new_props) $$invalidate(6, hideStatusbarOnOpen = $$new_props.hideStatusbarOnOpen);
		if ("scrollableEl" in $$new_props) $$invalidate(7, scrollableEl = $$new_props.scrollableEl);
		if ("swipeToClose" in $$new_props) $$invalidate(8, swipeToClose = $$new_props.swipeToClose);
		if ("closeByBackdropClick" in $$new_props) $$invalidate(9, closeByBackdropClick = $$new_props.closeByBackdropClick);
		if ("backdrop" in $$new_props) $$invalidate(10, backdrop = $$new_props.backdrop);
		if ("backdropEl" in $$new_props) $$invalidate(11, backdropEl = $$new_props.backdropEl);
		if ("noShadow" in $$new_props) $$invalidate(24, noShadow = $$new_props.noShadow);
		if ("noBorder" in $$new_props) $$invalidate(25, noBorder = $$new_props.noBorder);
		if ("padding" in $$new_props) $$invalidate(12, padding = $$new_props.padding);
		if ("$$scope" in $$new_props) $$invalidate(28, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(14, classes = classNames(
			className,
			"card",
			{
				"card-outline": outline,
				"card-expandable": expandable,
				"card-expandable-animate-width": expandableAnimateWidth,
				"no-shadow": noShadow,
				"no-border": noBorder
			},
			colorClasses($$props)
		));

		if ($$self.$$.dirty[0] & /*expandableOpened*/ 524288) {
			$: watchOpened(expandableOpened);
		}
	};

	$: $$invalidate(15, hasHeaderSlots = $$slots.header);
	$: $$invalidate(16, hasContentSlots = $$slots.content);
	$: $$invalidate(17, hasFooterSlots = $$slots.footer);
	$$props = exclude_internal_props($$props);

	return [
		title,
		content,
		footer,
		animate,
		hideNavbarOnOpen,
		hideToolbarOnOpen,
		hideStatusbarOnOpen,
		scrollableEl,
		swipeToClose,
		closeByBackdropClick,
		backdrop,
		backdropEl,
		padding,
		el,
		classes,
		hasHeaderSlots,
		hasContentSlots,
		hasFooterSlots,
		$$restProps,
		expandableOpened,
		className,
		outline,
		expandable,
		expandableAnimateWidth,
		noShadow,
		noBorder,
		slots,
		div_binding,
		$$scope
	];
}

class Card extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				class: 20,
				title: 0,
				content: 1,
				footer: 2,
				outline: 21,
				expandable: 22,
				expandableAnimateWidth: 23,
				expandableOpened: 19,
				animate: 3,
				hideNavbarOnOpen: 4,
				hideToolbarOnOpen: 5,
				hideStatusbarOnOpen: 6,
				scrollableEl: 7,
				swipeToClose: 8,
				closeByBackdropClick: 9,
				backdrop: 10,
				backdropEl: 11,
				noShadow: 24,
				noBorder: 25,
				padding: 12
			},
			[-1, -1]
		);
	}
}

export default Card;